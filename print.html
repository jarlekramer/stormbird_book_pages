<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stormbird</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Stormbird</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Stormbird book!</p>
<p>Stormbird is a library for simulating lifting surfaces, e.g., wings, in a simplified way by representing them as <em>line-models</em>. Although this can be used for a variety of different cases, it is mostly developed to offer efficient modeling of <em>modern wind propulsion devices</em>. That is, the following types of lifting surfaces are of particular interest:</p>
<ol>
<li>Wing sails</li>
<li>Rotor sails</li>
<li>Suction sails</li>
<li>Kites</li>
</ol>
<figure>
    <img src="static/actualtor_line_streamlines.png" alt="Actuator line streamlines">
    <figcaption>Figure 1: Examples of streamlines around wing sails that are simulated with this library.</figcaption>
</figure>
<p>To achieve practical modeling capabilities for these use cases, the following physical effects are assumed to be particularly important:</p>
<ul>
<li><strong>Various lift generation mechanisms</strong>: modern sails have <em>sections</em> that range from classical foils, with and without flaps, rotating cylinders, and foils with boundary layer suction.</li>
<li><strong>Strong viscous effects:</strong> For all lift generating mechanisms above, there will be high lift coefficients with strong viscous effects on both the lift and drag forces. For instance, wing sails tend to be operated close to stall, the lift on a rotating cylinder is strongly affected by partial flow separation, and the lift on a suction sail is very dependent on the amount of boundary layer suction.</li>
<li><strong>Interaction effects between lifting surfaces:</strong> Many wind-powered ships have several sails placed in close proximity. Interaction effects between multiple sails can therefore be important.</li>
<li><strong>Interaction effects with other structures:</strong> Independent of the number of sails, there can be interaction effects between the sails and the rest of the ship, such as structures on deck or the part of the hull that is above the water line.</li>
<li><strong>Unsteady effects:</strong> Ship applications often require modeling of unsteady effects, for instance, to model seakeeping behavior or maneuvering. The sail forces are assumed to be important for such cases, which also introduces dynamic effects on the sails. In addition, kites are often flown dynamically to increase the power extracted from the wind.</li>
</ul>
<p>At the same time, it is also often necessary that the computations are fast. The user will usually be interested in testing many different weather conditions, ship speeds, sail configurations, and operational variables. The goal is, therefore, to find the right balance between accuracy and speed for the intended use case. To achieve this, the library supports the following methods, that offer different levels of complexity and computational speed:</p>
<ol>
<li><strong>Discrete static lifting line</strong>, for steady- or quasi-steady cases</li>
<li><strong>Discrete dynamic lifting line</strong>, for unsteady or steady cases with large wake deformations</li>
<li><strong>Actuator line</strong>, for steady and unsteady cases where interaction with other structures is of interest</li>
</ol>
<p>The library is developed as part of the research project <a href="https://www.sintef.no/en/projects/2023/wind-enabling-zero-emission-shipping-with-wind-assisted-propulsion/">KSP WIND</a> by the Department of Marine Technology at the <a href="https://www.ntnu.edu/">Norwegian University of Science and Technology</a>. The main developer is Jarle Vinje Kramer.</p>
<h2 id="who-the-book-is-for"><a class="header" href="#who-the-book-is-for">Who the Book is for</a></h2>
<p>You should read this if you are interested in using Stormbird to run lifting line or actuator line simulations, or if you just want more information on the theory behind each method. The book is intended to introduce the theory, available models, and overall concepts in the implementation. In other words, the goal is to give a bird's-eye view of the library and its functionality. When appropriate, other literature will be referenced for more details. That is, it is written primarily for <em>users</em>, and are therefore not focused directly on the underlying source code. However, there will often be examples from the source code when that is the easiest way to illustrate functionality. For instance, data structures will often be shown directly source code to illustrate what fields and settings that are available.</p>
<h2 id="dont-forget-to-also-look-at-the-code"><a class="header" href="#dont-forget-to-also-look-at-the-code">Don't forget to also look at the code!</a></h2>
<p>The text in this book will not cover everything! It may also, at times, be outdated relative to the latest version of the library. The only way to get a full insight into the inner workings is, therefore, to look at the source code itself and the examples of how to use the code. Below is some relevant links for this purpose</p>
<ul>
<li>The Stormbird GitHub page can be found <a href="https://github.com/NTNU-IMT/stormbird">here</a>. It contains the core library, utility functionality, interfaces and examples.</li>
<li>More specifically, examples of how to use the Python interface of the code can be found <a href="https://github.com/NTNU-IMT/stormbird/tree/main/interfaces/pystormbird/examples">here</a>.</li>
<li>Automated code documentation can be found <a href="https://docs.rs/stormbird/0.7.0/stormbird/">here</a> for the core Stormbird library and <a href="https://docs.rs/stormath/0.1.1/stormath/">here</a> for the Stormath library, which contains mathematical utility functionality written for Stormbird.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-of-different-versions"><a class="header" href="#overview-of-different-versions">Overview of different versions</a></h1>
<p>Stormbird itself is a <a href="https://www.rust-lang.org/">Rust</a> library. The Rust programming language was chosen as it combines high computational speed with a modern user-friendly developer experience. One potential way to set up a Stormbird simulation is, therefore, to make a custom Rust executable. However, for those that don't know Rust, or just want to use the library in a high-level setting, it is also possible to use one of the <em>high-level</em> interfaces to the core functionality, listed below:</p>
<ul>
<li><strong>The Python interface</strong>, implemented in the <code>pystormbird</code> module. This interface is a direct API to the <em>necessary</em> Rust functions and data structures for running lifting line simulations. This allows for scripting the setup and execution of simulations using Python. More information about the interface will often be mentioned throughout the rest of the book, as well as a high-level description that can be found <a href="different_versions/python_interface.html">here</a>.</li>
<li><strong>The <a href="https://fmi-standard.org/">Functional Mockup Interface</a></strong>, implemented in the <code>StormbirdLiftingLine</code> FMU. This interface is more restricted in what it can do, relative to the Python interface, but serves as a practical way to execute sail simulations together with other FMU-models representing the ship. More information about the FMU-interface can be found <a href="different_versions/fmu_version.html">here</a></li>
<li><strong>The OpenFOAM interface</strong> for running actuator line simulations with <a href="https://www.openfoam.com/">OpenFOAM</a> as the CFD solver. This interface is yet to be described in this book. To come.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-about-input-and-output"><a class="header" href="#general-about-input-and-output">General about input and output</a></h1>
<p>Stormbird, as any library, consist of many data structures. Some represents the settings for a simulations, such as wake and solver parameters, while others represent input to or result from a simulation. To create and run a simulation it is generally necessary to pass information to the library about the data structures that you whish to create. This is the case for all the interfaces.</p>
<p>To facilitate simple serialization and deserialization - at least from a coding perspective - Stormbird relies heavily on the <a href="https://serde.rs/">Serde</a> library. This is "[..] a framework for <strong>ser</strong>ializing and <strong>de</strong>serializing Rust data structures efficiently and generically". In other words, it is a library to automate the conversion of data structures to and from different file formats. Serde supports many formats, but JSON has been chosen for Stormbird. This means that any input must be passed as JSON strings, and output will often also be delivered as JSON strings.</p>
<p>Working with Stormbird is therefor often a matter of setting up the right input in a JSON format and then reading and parsing the output from the resulting JSON format.</p>
<p>Throughout this book there will be examples of data structures shown as Rust code. This is generally to show the available fields in a structure, to give an impression of which variables it is possible to set. All of these Rust-structures has a corresponding JSON representation. A simple example of how a generic Rust structure is converted to a JSON string from Serde is shown below.</p>
<p>An example of a Rust struct first:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SpatialVector {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
<span class="boring">}</span></code></pre></pre>
<p>Then the corresponding JSON version with the input data</p>
<pre><code class="language-json">{
    "x": 1.0,
    "y": 0.0,
    "z": 1.2
}
</code></pre>
<p>An example of a complete input string to Stormbird can be seen below. More explanations about this input will come later:</p>
<pre><code class="language-json">{
    "line_force_model": {
        "wing_builders": [
            {
                "section_points": [
                    {"x": 125.0, "y": 0.0, "z":-20.0},
                    {"x": 125.0, "y": 0.0, "z":-60.0}
                ],
                "chord_vectors": [
                    {"x": -8.0, "y": 0.0, "z": 0.0},
                    {"x": -8.0, "y": 0.0, "z": 0.0}
                ],
                "section_model": {
                    "Foil": {}
                }
            },
            {
                "section_points": [
                    {"x": 45.0, "y": 0.0, "z": -20.0},
                    {"x": 45.0, "y": 0.0, "z": -60.0}
                ],
                "chord_vectors": [
                    {"x": -8.0, "y": 0.0, "z": 0.0},
                    {"x": -8.0, "y": 0.0, "z": 0.0}
                ],
                "section_model": {
                    "Foil": {}
                }
            }
        ],
        "nr_sections": 10
    },
    "simulation_mode": {
        "Dynamic": {
            "wake": {
                "ratio_of_wake_affected_by_induced_velocities": 0.25
            },
            "solver": {
                "damping_factor": 0.2,
                "max_iterations_per_time_step": 3
            }
        }
    },
    "write_wake_data_to_file": true,
    "wake_files_folder_path": "output/wake_files"
}
</code></pre>
<h2 id="default-values"><a class="header" href="#default-values">Default values</a></h2>
<p>Default values are often given for structures representing settings or models. This means that it may not be necessary to specify every field in a structure in the input. For instance, in the example above, the <code>"wake"</code> structure only has one specified variable. However, the complete wake structure has 12 fields, where some are other structures with more sub fields. The reason only the <code>"ratio_of_wake_affected_by_induced_velocities"</code> is given above is that this was the only setting where a different value than the default was wanted.</p>
<p>The goal is to implement reasonable default values on as many variables as possible.</p>
<h2 id="helper-library-to-create-the-right-json-settings"><a class="header" href="#helper-library-to-create-the-right-json-settings">Helper library to create the right JSON settings</a></h2>
<p>Much of the setup of Stormbird models can be done using a Python library called <code>stormbird_setup</code>. This library is implemented independent of of the core library, and should be useful for all interfaces. It makes different settings available as Python classes that inherits from the <a href="https://docs.pydantic.dev/latest/api/base_model/">Pydantic BaseModel</a>. This makes serializing of the data structures straight forward, and the setup of the models come with typed check validation. That is, the only purpose of the library is to ease the generation of the right JSON strings, and can therefore be used no matter how stormbird is executed, and in combinations with manually generated strings if that is needed. The library also implements some high-level shortcut-functionality for generating typical simulation settings for different cases. See the package folder on GitHub or the examples in the pyfoamsetup folder for more on how to use <code>stormbird_setup</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-interface"><a class="header" href="#python-interface">Python interface</a></h1>
<p>The Python interface to Stormbird is made using a Rust library called <a href="https://pyo3.rs/">PyO3</a>. As a general principle, there is a one-to-one relationship between the functionality available in Python and Rust equivalent functionality. That is, names are kept identical in both languages, and the programming constructs are kept as similar as possible (e.g, data structures in Rust becomes classes in Python, etc.)</p>
<p>Examples of how to use the Python functionality can be found in the <a href="https://github.com/NTNU-IMT/stormbird/tree/main/interfaces/pystormbird/examples">pystormbird examples folder</a> at the Stormbird github page</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>To build and install the package, it is necessary to have a Rust compiler installed on your system as well as Python. With this in place, in should be as easy as a normal pip installation.</p>
<p>For instance, you can navigate to the <code>pystormbird</code> folder in a terminal and execute</p>
<pre><code>pip install .
</code></pre>
<h2 id="still-a-lot-of-json-input-and-output"><a class="header" href="#still-a-lot-of-json-input-and-output">Still a lot of JSON input and output</a></h2>
<p>Only a limited set of the Rust library has a direct Python interface. For instance, data structures that primarily contains input, and which are therefore not needed directly in a high-level interfaces (such as <code>builder</code> structures) do not have a direct implementation in <code>pystormbird</code>. It is generally seen as uncesseary as the same settings can be passed as JSON strings, which are then deserialized into the right structures on the Rust side. Avoiding a direct Python implementation drastically reduces the development overhead when, for instance, something changes in the core library.</p>
<p>As such, even when using the Python interface to Stormbird, the task is often to create and pass in the right formatted JSON strings to, for instance, initializer methods to create new objects. This is, however, fairly simple as Python has excellent support for converting dictionaries into JSON strings. In addition, the <code>stormbird_setup</code> library can ease the creating of JSON strings in most situations.</p>
<p>An example of how this works is shown below, where a multi-element foil model for a Stormbird simulation is created from input data that is set up as Python dictionaries, which are then converted to a JSON string:</p>
<pre><code class="language-python">import numpy as np
import json
from pystormbird.section_models import VaryingFoil

# Parameters for the model, representing the foil forces at different lap angles
flap_angles = np.radians([0, 5, 10, 15])

cl_zero_angle = np.array([0.0, 0.3454, 0.7450, 1.0352])
mean_stall_angle = np.radians([20.0, 19.0 , 17.8, 16.5])

cd_zero_angle = np.array([0.0101, 0.0154, 0.0328, 0.0542])
cd_second_order_factor = np.array([0.6, 0.9, 1.2, 1.5])

# Loop over the parameters to create individual foil models
foils_data = []
for i_flap in range(len(flap_angles)):
    foils_data.append(
        {
            "cl_zero_angle": cl_zero_angle[i_flap],
            "cd_zero_angle": cd_zero_angle[i_flap],
            "cd_second_order_factor": cd_second_order_factor[i_flap],
            "mean_stall_angle": mean_stall_angle[i_flap]
        }
    )

# Collect the foil models into a "varying foil" model
foil_dict = {}

foil_dict["internal_state_data"] = flap_angles.tolist()
foil_dict["foils_data"] = foils_data

# Generate a JSON input string
input_str = json.dumps(foil_dict)

# Pass it to the Stormbird library
foil_model = VaryingFoil(input_string)
</code></pre>
<p>The same example with the <code>stormbird_setup</code> library would look like this:</p>
<pre><code class="language-python">import numpy as np
from pystormbird.section_models import VaryingFoil

# General structures for storing the right variables in a class
from stormbird_setup.direct_setup.section_models import Foil

# Change the name of the VaryingFoil class from stormbird_setup to avoid name clash
from stormbird_setup.direct_setup.section_models import VaryingFoil as VaryingFoilSetup


# Parameters for the model, representing the foil forces at different lap angles
flap_angles = np.radians([0, 5, 10, 15])

cl_zero_angle = np.array([0.0, 0.3454, 0.7450, 1.0352])
mean_stall_angle = np.radians([20.0, 19.0 , 17.8, 16.5])

cd_zero_angle = np.array([0.0101, 0.0154, 0.0328, 0.0542])
cd_second_order_factor = np.array([0.6, 0.9, 1.2, 1.5])

# Loop over the parameters to create individual foil models
foils_data = []
for i_flap in range(len(flap_angles)):
    foils_data.append(
        Foil(
            cl_zero_angle: cl_zero_angle[i_flap],
            cd_zero_angl: cd_zero_angle[i_flap],
            cd_second_order_factor: cd_second_order_factor[i_flap],
            mean_stall_angle: mean_stall_angle[i_flap]
        )
    )

# Collect the foil models into a "varying foil" model
varying_foil_setup = VaryingFoilSetup(
    internal_state_data = flap_angles.tolist(),
    foils_data = foils_data
)

# Pass it to the Stormbird library
foil_model = VaryingFoil(varying_foil_setup.to_json_string())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-mockup-unit"><a class="header" href="#functional-mockup-unit">Functional Mockup Unit</a></h1>
<p>The lifting line functionality in Stormbird is available as a <em>Functional Mockup Unit</em>, which means that the functionality can be executed through the <a href="https://fmi-standard.org/">Functional Mockup Interface standard</a>. The actual interface is generated using the <a href="https://github.com/jarlekramer/fmu_from_struct">fmu_from_struct</a> library, which is made by the same developer as Stormbird.</p>
<h2 id="how-to-execute-simulations-using-the-fmu-version"><a class="header" href="#how-to-execute-simulations-using-the-fmu-version">How to execute simulations using the FMU-version</a></h2>
<p>The FMU-version is currently made to support version 2 of the FMI-standard. This choice is made because the developers of Stormbird primarily uses the <a href="https://opensimulationplatform.com/">Open Simulation Platform</a> for executing simulations, which currently only supports version 2. An FMU that supports version 3 of the FMI-standard is relatively straight forward to make, but will probably not be prioritized before the Open Simulation Platform is updated to the latest version.</p>
<p>A simulation can be executed with any simulation platform that supports the FMI-standard. One example is the <a href="https://open-simulation-platform.github.io/cosim">command line interface</a> from the Open Simulation Platform, or some Python interface to FMU's such as <a href="https://github.com/CATIA-Systems/FMPy">FMPy</a> or <a href="https://jmodelica.org/pyfmi/">PyFMI</a>.</p>
<p>To actually set up a simulation, it is necessary to pass in several parameter- and input variables to the FMU unit. For a full overview of the available variables, see the <a href="https://github.com/NTNU-IMT/stormbird/tree/main/interfaces/fmus/stormbird_lifting_line">FMU source code</a>. To see how it can be used in practice, see the <a href="https://github.com/NTNU-IMT/stormbird/tree/main/interfaces/fmus/examples">FMU example folder</a>.</p>
<h2 id="what-can-the-fmu-version-do"><a class="header" href="#what-can-the-fmu-version-do">What can the FMU-version do?</a></h2>
<p>The FMI-interface inherently comes with more limitations than a conventional API, such as the Python interface. For instance, there are limitations on what type of variables that can be passed to and from different FMUs, and there is a specific order to how functions are executed. Although there are many ways to work around these limitations, the FMU-version of Stormbird is, for simplicity sake, designed to only cover the most typical use cases for running dynamic lifting line simulations. That is, <strong>it is not intended to be a direct alternative to the Python interface</strong>, but rather a specialized way to use <em>some</em> of the functionality.</p>
<p>To be more specific, there are essentially two primary use cases for the Stormbird FMU:</p>
<ol>
<li><strong>Coupling of Stormbird to a time-domain ship simulator</strong>, such as <a href="https://www.sintef.no/en/software/vesim/">VeSim</a>. VeSim is a ship simulator that includes maneuvering and seakeeping models of ships. It can, for instance, simulate a ship moving in waves, including the effect of rudder action and control systems. The software is built around the FMI-standard to couple different sub-models together. Stormbird can, therefore, be one of many models in a ship-system simulations in the time-domain.</li>
<li><strong>Running sail simulations in hybrid experiments</strong>. Hybrid experiments are experiments where part of the physics is measured experimentally, while other parts are simulated. In the specific case of wind-powered ships, the aerodynamic forces on the sails are simulated while the hydrodynamics are tested in a towing tank. <a href="https://www.sciencedirect.com/science/article/pii/S0029801821015213?via%3Dihub">This article</a> explains more of how this is done at SINTEF Ocean. The Stormbird FMU was designed to fit well with the laboratory software used at SINTEF Ocean when doing hybrid tests, called <a href="https://www.sintef.no/programvare/hlcc/">HLCC</a>.</li>
</ol>
<p>There are no direct coupling to VeSim or HLCC in the Stormbird FMU, but the choice of input and output variables was made, in part, based on what makes sense for these external software packages. That is, the design of the Stormbird FMU interface is not made in isolation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openfoam-version"><a class="header" href="#openfoam-version">OpenFOAM version</a></h1>
<p><a href="https://www.openfoam.com/">OpenFOAM</a> is a general open source CFD solver, widely used both in academia and in industry.</p>
<p>The OpenFOAM version of Stormbird is currently the only way to run actuator line simulations. It consist of a volume force interface between the Stormbird library and the OpenFOAM library, that can be activated together with a solver in OpenFOAM.
More details about this interface can be found both in the <a href="different_versions/../actuator_line/actuator_line.html">actuator line chapter</a> and the specific chapter about the <a href="different_versions/../actuator_line/openfoam_interface.html">OpenFOAM interface</a>.</p>
<p>As a general not, this interface could also serve as an inspiration for how to connect Stormbird to other CFD solvers, if this turns out to be relevant in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="line-model-representation-of-wings"><a class="header" href="#line-model-representation-of-wings">Line model representation of wings</a></h1>
<p>The fundamental building block of all the methods in Stormbird is a simplified <em>line representation</em> of the lifting surfaces. This means that the full geometry of the wings is reduced to multiple discrete <strong>line elements</strong>. Each line element represents a section of a lifting surface that has the following properties:</p>
<ul>
<li>A <strong>line segment geometry</strong>, represented as a start point and and end point, defining the location and orientation of the element. The line segment also has <em>control point</em>, defined to be in the middle of the line segment. This point is used when computing local flow properties for the element during a simulation.</li>
<li>A <strong>chord vector</strong>, which defines both the orientation and length of the chord. The orientation is relevant for computing the angle of attack as a function of the local velocity, while the length is relevant for computing the magnitude of the forces.</li>
<li>A <strong>sectional model</strong> which is used to compute lift- and drag coefficients as a function of the local flow properties. The line model itself makes no assumptions about how the lift and drag is computed. However, Stormbird comes with a limited set of sectional models that are further described in <a href="line_model//sectional_models/sectional_models_intro.html">Sectional models</a>. <strong>Note</strong>: in the actual implementation, the section model is not actually stored for each line element, because most of the time, many elements will share the same sectional model. However, when iterating over line elements in the code there is a functionality to retrieve the relevant sectional model for that line element.</li>
</ul>
<h2 id="structure-overview"><a class="header" href="#structure-overview">Structure overview</a></h2>
<p>A view of source code that defines a line force model data structure can be seen below to illustrate what data is available. There are also multiple methods connected to this data structure not shown here. The construction of a line force model is generally not done manually, but rather by a <a href="line_model/./building_line_model.html">builder</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LineForceModel {
    pub span_lines_local: Vec&lt;SpanLine&gt;,
    pub chord_vectors_local_not_rotated: Vec&lt;SpatialVector&gt;,
    pub chord_lengths: Vec&lt;f64&gt;,
    pub section_models: Vec&lt;SectionModel&gt;,
    pub wing_indices: Vec&lt;Range&lt;usize&gt;&gt;,
    pub non_zero_circulation_at_ends: Vec&lt;[bool; 2]&gt;,
    pub density: f64,
    pub circulation_correction: CirculationCorrection,
    pub angle_of_attack_correction: AngleOfAttackCorrection,
    pub output_coordinate_system: CoordinateSystem,
    pub rigid_body_motion: RigidBodyMotion,
    pub local_wing_angles: Vec&lt;f64&gt;,
    pub chord_vectors_local: Vec&lt;SpatialVector&gt;,
    pub chord_vectors_global: Vec&lt;SpatialVector&gt;,
    pub chord_vectors_global_at_span_points: Vec&lt;SpatialVector&gt;,
    pub span_lines_global: Vec&lt;SpanLine&gt;,
    pub span_points_global: Vec&lt;SpatialVector&gt;,
    pub ctrl_points_global: Vec&lt;SpatialVector&gt;,
    pub ctrl_point_spanwise_distance: Vec&lt;f64&gt;,
    pub ctrl_point_spanwise_distance_non_dimensional: Vec&lt;f64&gt;,
    pub ctrl_point_spanwise_distance_circulation_model: Vec&lt;f64&gt;,
    pub input_power_models: Vec&lt;InputPowerModel&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>More details on each field can be found in the code <a href="https://docs.rs/stormbird/0.7.0/stormbird/">documentation</a>. The construction of a line force model is generally not done with the structure directly, but rather through a <a href="line_model//line_model/building_line_model.html">builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-line-model"><a class="header" href="#building-a-line-model">Building a line model</a></h1>
<p>As shown in the <a href="line_model/./line_model_intro.html">intro section</a>, a line model consist of many line elements. To simplify the construction of this line model, Stormbird uses a <em>line force model builder</em> that helps with at least two things:</p>
<ol>
<li><strong>Reduce the amount of input data:</strong> Rather than having to specify data directly for each line element, it is possible to only specify data at some chosen points along the span - such as the beginning and the end - and let the builder interpolate for every line segment between the specified points</li>
<li><strong>Automate the setup of multiple wings:</strong> The line force model requires information about which line element belongs to which wing. This can be cumbersome to set up manually, and it is not really necessary to do so. The builder automatically keep tracks of which line element belong to which wing.</li>
</ol>
<h2 id="input-data"><a class="header" href="#input-data">Input data</a></h2>
<p>The Rust definition of the builder structure looks like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LineForceModelBuilder {
    pub wing_builders: Vec&lt;WingBuilder&gt;,
    pub nr_sections: usize,
    pub density: f64,
    pub circulation_correction: CirculationCorrectionBuilder,
    pub output_coordinate_system: CoordinateSystem,
    pub local_wing_angles: Vec&lt;f64&gt;,
    pub rotation: SpatialVector,
    pub translation: SpatialVector,
}
<span class="boring">}</span></code></pre></pre>
<p>The only required input is the vector containing  <code>WingBuilder</code> structures and the <code>nr_sections</code> <sup class="footnote-reference" id="fr-nr_sections_note-1"><a href="#footnote-nr_sections_note">1</a></sup>. The nr sections should be tested for each project, and will affect both the accuracy and the computational speed. Typical values range between 10-50. The <code>density</code> is set to the <a href="https://en.wikipedia.org/wiki/Density_of_air">standard air density for 15 degrees Celsius</a> by default ( which = 1.225 kg / m^3).</p>
<p>The <code>circulation_corrections</code> is an enum, where the default variant is <code>None</code>, and therefore not used by default. There will be more on the circulation corrections option <a href="line_model/./circulation_strength.html">later</a>. This is only used in special circumstances, for instance when a pure lifting line simulation might fail due to numerical issues.</p>
<p>The <code>output_coordinate_system</code> is an enum that specifies how the forces and moments from the line force model should be calculated. The default is <code>Global</code>, which means all values are in a global coordinate system. That is, the coordinate system for the forces are not moved even if the wings are moved during a simulation. The other option is to set it to <code>Body</code>. In this case, the coordinate system of the forces will always follow the wings when they are moved.</p>
<p>The <code>local_wing_angles</code>, <code>rotation</code>, and <code>translation</code> specifies the initial values for the local rotation of the wing angles as well as the global rotation and translation of the whole line force model. See the <a href="line_model//line_model/move_line_models.html">move line models chapter</a> for more.</p>
<h3 id="wing-builder"><a class="header" href="#wing-builder">Wing builder</a></h3>
<p>A wing builder contain data to build line segments for a single wing. When a vector (or list) of wing builders are provided, the <code>LineForceModelBuilder</code> will automatically keep track of which line segment belong to each wing. The fields in a <code>WingBuilder</code> structure is as shown as Rust code below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WingBuilder {
    pub section_points: Vec&lt;SpatialVector&lt;3&gt;&gt;,
    pub chord_vectors: Vec&lt;SpatialVector&lt;3&gt;&gt;,
    pub section_model: SectionModel,
    pub non_zero_circulation_at_ends: [bool; 2],
    pub nr_sections: Option&lt;usize&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The input consist of a set of <code>section_points</code> which contain information about the span line position. The minimum number of section points is two, and the first has to start at one end of the wing, while the last must end up at the other. There can, however, also be more section points in between the ends.</p>
<p>For each section point, there also needs to be <code>chord_vectors</code>, which specify the local chord at the points. The <code>chord_vectors</code> give information about both chord length and orientation.</p>
<p>Each wing also needs a <a href="line_model/./../sectional_models/sectional_models_intro.html">sectional model</a>. The sectional model can differ between different wings given to the <code>LineForceModelBuilder</code>, which is useful for cases where different sail types are installed on the same ship (uncommon today, but might happen in the future).</p>
<p>The <code>non_zero_circulation_at_ends</code> is boolean values that specifies the expected behavior of the circulation distribution at the ends of the wing. It is used when initializing the circulation distribution before a simulation, and when applying corrections to the circulation distribution. In most cases, the expected value of the circulation strength at the ends is zero, and the value of this variable should be <code>[false, false]</code>. However, if, for instance, the wing is standing directly on a symmetry plane, or is directly coupled to another wing, the circulation distribution will typically not be zero. If an end is coupled to <em>something</em> that might give a non-zero circulation, then that end should then get a <code>true</code> value. For instance, if the first end is standing on a symmetry plane, the value of this variable should be <code>[true, false]</code>.</p>
<p>The <code>nr_sections</code> variable is optional but can be set for each wing to override the default parameters in the <code>LineForceModelBuilder</code>. Typically, it will not be used, as the most common scenario is to have the same number of sections for each wing.</p>
<p>When building a line force model from a wing builder, the wings are divided into multiple line segments based on the data in the <code>WingBuilder</code> structure. Each point in between the specified points are linearly interpolated <sup class="footnote-reference" id="fr-interpolation_note-1"><a href="#footnote-interpolation_note">2</a></sup></p>
<h2 id="input-to-methods"><a class="header" href="#input-to-methods">Input to methods</a></h2>
<p>In many cases, the methods in Stormbird will handle the actual building of the line force models automatically, using a builder structure as input. That is, the input to some function is often the builder and not the line force model itself. For instance, when setting up a lifting line simulation in Python, you only have to supply the builder data, and the line force model will be built automatically internally.</p>
<p>However, it is also possible to convert a builder into a line force model. This happens by calling the <code>build()</code> method, as usual for Rust builder structures.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-nr_sections_note">
<p>The number of sections for set in the <code>LineForceModelBuilder</code> is used as default, except when another value is defined in the <code>WingBuilder</code> below. <a href="#fr-nr_sections_note-1">↩</a></p>
</li>
<li id="footnote-interpolation_note">
<p>The interpolation method is possible to change or update to something that can handle non-linear changes between section points. This is, however, so far not prioritized as most sail types tend to use fairly simple geometrical structures. This might change in the future if there is a need to do so. <a href="#fr-interpolation_note-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="circulation-strength"><a class="header" href="#circulation-strength">Circulation strength</a></h1>
<p>The circulation strength along a wing determines both the magnitude of the lift-forces and the induced velocities from the wing. The velocity is affected either through induced velocities from a wake model based on potential theory, in the case of lifting line simulations, or through body forces projected into a CFD domain, in the case of actuator line simulations.</p>
<p>This chapter specifies how the circulation strength is estimated from the local velocity on each line section, and how it is possible to modify the estimation for stability purposes. The procedure is the same for all simulation methods in Stormbird. That is, there are no differences in this regard between the static lifting line, dynamic lifting line or the actuator line. The responsibility for calculating the values are therefore given to the line force model.</p>
<h2 id="raw-lifting-line-theory-estimation"><a class="header" href="#raw-lifting-line-theory-estimation">Raw lifting line theory estimation</a></h2>
<p>The calculation of the circulation strength on each line element follows the <a href="https://en.wikipedia.org/wiki/Kutta%E2%80%93Joukowski_theorem">Kutta–Joukowski theorem</a>. The mathematical definition of the circulation value, \( \Gamma \), on a line element is as follows, where \(U \) is the velocity, and \( L \) is the lift per unit span.</p>
<p>\[
\Gamma = L / (U \rho)
\]</p>
<p>The lift per unit span is further computed from the sectional lift coefficient, \(C_L\) as follows, where \(\rho\) is the density and \(c \) the chord length:</p>
<p>\[
L = 0.5 \cdot \rho \cdot c \cdot C_L \cdot U^2
\]</p>
<p>When these equations are combined, we get the following equation for the circulation strength:</p>
<p>\[
\Gamma = 0.5 \cdot c \cdot C_L \cdot U
\]</p>
<p>The actual source code looks like the following (the negative values are to account for directional definitions)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn circulation_strength_raw(&amp;self, velocity: &amp;[Vec3]) -&gt; Vec&lt;f64&gt; {
    let cl = self.lift_coefficients(&amp;velocity);

    (0..velocity.len()).map(|index| {
        -0.5 * self.chord_vectors_local[index].length() * velocity[index].length() * cl[index]
    }).collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="optional-corrections"><a class="header" href="#optional-corrections">Optional corrections</a></h2>
<p>Sometimes, there might be noise in the estimated circulation strength, which might cause instabilities and errors in the estimated forces. A typical examples is lifting line simulations of stalled wings - especially when the lift coefficient is very large.</p>
<p>To handle such cases in a practical manner, there are optional <em>corrections methods</em> that can be used when estimating the circulation strength. These methods are controlled through a <code>CirculationCorrection</code> enum that is specified for the line force model. To set up different types of corrections, a <code>CirculationCorrectionBuilder</code> is used, which has the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum CirculationCorrectionBuilder {
    None,
    Prescribed(PrescribedCirculation),
    Smoothing(CirculationSmoothingBuilder),
}
<span class="boring">}</span></code></pre></pre>
<p>The default variant is <code>None</code>, which means that no corrections are applied. The effect of the other variants are explained below.</p>
<h3 id="smoothing"><a class="header" href="#smoothing">Smoothing</a></h3>
<p>The smoothing correction applies different types of smoothing filters to the estimated circulation, controlled through the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CirculationSmoothingBuilder {
    pub smoothing_type: SmoothingTypeBuilder,
    pub prescribed_to_subtract_before_smoothing: Option&lt;PrescribedCirculation&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The option to add a <code>prescribed_to_subtract_before_smoothing</code> is currently. It subtracts a prescribed circulation distribution (see more about this below) from the estimated circulation before applying the smoothing filter. After the smoothing is applied, the prescribed distribution is added back to the smoothed result. The idea behind this is that it can avoid issues with smoothing the rapidly changing circulation at the wing tips. By subtracting a known distribution first, the smoothing filter only needs to handle the more noisy part of the circulation distribution. However, the this feature is still experimental, and should be used with care.</p>
<p>The <code>smoothing_type</code> field specifies which type of smoothing filter should be applied. The available options are shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SmoothingTypeBuilder {
    Gaussian(GaussianSmoothingBuilder),
    CubicPolynomial(CubicPolynomialSmoothingBuilder),
}
<span class="boring">}</span></code></pre></pre>
<p>The first smoothing type is <a href="https://en.wikipedia.org/wiki/Kernel_smoother">Gaussian smoothing filter</a>. The available fields are shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GaussianSmoothingBuilder {
    pub smoothing_length_factor: f64,
    pub number_of_end_points_to_interpolate: usize
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>smoothing_length_factor</code> gives a factor used to calculated the smoothing length from the span of each wing in the line force model. That is, if the value is set to 0.01, the smoothing length will be 1% of the total span of each wing, independent of the value of the wing span or the number of sections.</p>
<p>The <code>number_of_end_points_to_interpolate</code> field specifies how many points at each end of the wing that should be inserted beyond the tips of the wings before applying the smoothing. Which values that are inserted beyond the tips are dependent on wether the circulation is expected to be zero or not, controller by the <code>non_zero_circulation_at_ends</code> field in the line force model. If the circulation is expected to have zero circulation, the additional points are set to zero. If not, the values are linearly extrapolated from the inner points. If this value is not set, the default will be to calculate the number of insertion points based on the smoothing length and the number of sections. This should be sufficient in most cases.</p>
<p>An example of how this smoothing method affects the circulation distribution is illustrated in the figure below. <strong>Note</strong>: the example is with an excessive amount of noise, and is not representative of actual numerical noise from a lifting line simulation. Rather, it shows an example where an artificial elliptic circulation distribution was first generated, and then modified by adding random numerical noise. The plot then shows how the noise is reduced when the noisy circulation distribution is corrected using the Gaussian smoothing filer, with different values for the <code>gaussian_length_factor</code>.</p>
<p><img src="line_model/figures/gaussian_smoothing_example.png" alt="Gaussian smoothing example" /></p>
<p>As can bee seen, simple Gaussian smoothing introduces some errors towards the end of the wings if the smoothing length is too large, although the random noise is effectively reduced. It is therefore generally recommended to only apply as little smoothing as necessary to stabilize a solution.</p>
<p>The second smoothing type is a cubic polynomial smoothing filter, which assumes that a cubic polynomial can be fitted to the points with a certain <code>window_size</code>. The larger the window size, the more smoothing is applied. The available fields are shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum WindowSize {
    Five,
    Seven,
    Nine
}

pub struct CubicPolynomialSmoothingBuilder {
    pub window_size: WindowSize,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="prescribed-distribution"><a class="header" href="#prescribed-distribution">Prescribed distribution</a></h2>
<p>Predetermined circulation distributions are a special mode where the circulation is forces to always follow a simple mathematical shape. For instance, it is possible to force the distribution to always be elliptical. This gives very stable simulations, and sometimes results that are very close a <em>full simulation</em>. It is particular useful if the goal is only to estimate interaction effects between wings, but where the lift and drag for a single wing is already known from, for instance, experimental or CFD results.</p>
<p>A view of the <code>PrescribedCirculation</code> structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PrescribedCirculationShape {
    pub inner_power: Float,
    pub outer_power: Float,
}

pub struct PrescribedCirculation {
    pub shape: PrescribedCirculationShape,
    pub curve_fit_shape_parameters: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>The option to <code>curve_fit_shape_parameters</code> is currently experimental. It will curve fit the shape parameters to the raw circulation distribution before applying the prescribed shape. However, it currently ends up with a relatively slow simulation, and the final results are not always better than just using default values for the shape parameters. It is set to false by default, and tuning it on should be used with care and testing.</p>
<p>The <code>PrescribedCirculationShape</code> parameters in the structure is used to force the circulation to always follow a mathematical shape that looks like the equation below, where \(s\) is the local non-dimensional span distance, varying from -0.5 to 0.5 along each wing:</p>
<p>\[
\Gamma(s) = \Gamma_0 (1.0 - (2 s)^{\text{inner_power}})^{\text{outer_power}}
\]</p>
<p>The default values are to set <code>inner_power</code> to 2.0 and <code>outer_power</code> to 0.5. This corresponds to an elliptic distributions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="move-and-modify-a-line-model"><a class="header" href="#move-and-modify-a-line-model">Move and modify a line model</a></h1>
<p>In dynamic simulations, it will often be interesting to apply motion to the sails and dynamically change the angle of attack or internal state of a section model. This can, for instance, be done to simulate how the sails affect the seakeeping or maneuvering abilities of a ship or to allow the operational variables of the sails be dependent on the current wind conditions. This chapter specifies how to apply motion data to the sails during a dynamic simulation and how to modify the operational variables for each sail.</p>
<h2 id="motion-variables"><a class="header" href="#motion-variables">Motion variables</a></h2>
<p>The motion of a line force model is specified by the <code>rigid_body_motion</code> field, which is of the <code>RigidBodyMotion</code> type. This structure looks like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RigidBodyMotion {
    pub translation: SpatialVector,
    pub rotation: SpatialVector,
    pub velocity_linear: SpatialVector,
    pub velocity_angular: SpatialVector,
    pub rotation_type: RotationType,
}
<span class="boring">}</span></code></pre></pre>
<p>It specifiies translation and rotation, both in terms of the curren positions and in terms of the velocities at any given time. The position is important both for updating the wake shape and for determining local wind conditions on each line segment. When applying the motion variables, the rotation will be applied first, then the translation. That is, the rotation happens around a local coordinate system always. The order of the rotation can be set with the <code>rotation_type</code> field, but the default is rotation in x first, then y, and then z.</p>
<p>The motion velocities, <code>velocity_linear</code> and <code>velocity_angular</code>, are important for the calcualtion of forces. The forces on the each line segment is primarily dependent on the local velocity, local angle of attack, and the internal state of the sectional models. As such, when a motion is applied to the line force model, it is necessary to calculate the <em>felt velocity</em> and <em>felt acceleration</em> of each line segment, so that this can further be used as input to the force calculation functions. This can be calculated from the gloabl rotation and translation velocity vectors using methods in the <code>RigidBodyMotion</code> structure. As will be further highlighted <a href="line_model/force_calculations.html">later</a>, the forces are estimated from a <code>SectionalForceInput</code> structure, which have fields as shown in the code block below. The velocity and acceleration values calculated in the <code>SectionalForceInput</code> structure are dependent on the motion of the sails.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SectionalForcesInput {
    pub circulation_strength: Vec&lt;f64&gt;,
    pub velocity: Vec&lt;SpatialVector&gt;,
    pub angles_of_attack: Vec&lt;f64&gt;,
    pub acceleration: Vec&lt;SpatialVector&gt;,
    pub rotation_velocity: SpatialVector,
    pub coordinate_system: CoordinateSystem,
}
<span class="boring">}</span></code></pre></pre>
<p>Each element in the vectors in the <code>SectionalForceInput</code> corresponds to a line element in the <code>LineForceModel</code>. Both the velocity and the acceleration is a combination of freestream conditions, induced velocities, and motion velocities. The motion velocities can either be automatically calcualted based on fintie difference and the time history of the motion or set manually if the variables are available from some other sources (e.g., a rigid body solver of a ship)</p>
<h2 id="control-variables"><a class="header" href="#control-variables">Control variables</a></h2>
<p>Two types of control variables exist for the sails in a <code>LineForceModel</code>.</p>
<p>The first is the <code>local_wing_angles</code>, which defines the rotation of the sails around its local axis. The local axis is defined as the axis of the first span line. If the sails is defined to be oriented in the z-direction as the span direction, a local wing angle value will then rotate all chord vectors around the z-axis.</p>
<p>The second value is the internal state of the section model for each wing. This value can represent different things, depending on the sail type and how it is modeled. Typical values are flap angles, rotational speeds, and suction rates.</p>
<h2 id="updating-the-lineforcemodel"><a class="header" href="#updating-the-lineforcemodel">Updating the LineForceModel</a></h2>
<p>When setting new values for either the motion variables or the control variables it is important to do it in way that also updates all dependent internal variables. For instance, many of the variables that define the geometry of the wings are defined both with their local values and their global values (e.g., <code>chord_vectors_local</code> and <code>chord_vectors_global</code>). In general, the global version of a variable type is calcualted from the local one, with the motion and wing angles applied to them. As such, updating the line force model should be done with <code>set</code> methods that also updates the global representation of the line force model.</p>
<p>The line force model have a general update function that should update all global geometry variables, and which should also be called after all <code>set</code> methods.</p>
<h3 id="motions"><a class="header" href="#motions">Motions</a></h3>
<p>Motion can be set in two ways: either with the position and rotation only, and using finite difference to calculate the corresponding velocities due to this motion, or by updating the velocity values manually. The first option is generally the easiest. However, the latter might be useful in cases where motion velocity is available from an external source, such as a rigid body solver that integrates the acceleration of an entire ship.</p>
<p>Below is some examples of how to apply different motion variables through the Python interface.</p>
<pre><code class="language-python">import numpy as np

from pystormbird.lifting_line import Simulation

# ----- code to set up the simulation first, which includes the line force model -----
simulation = Simulation(setup_string)

translation = [1.0, 2.0, 3.0]
rotation = np.radians([10.0, 0.0, 0.0]).tolist()

time_step = 0.1

# Update the translation and rotation with the velocity set by finite difference
simulation.set_translation_and_rotation_with_finite_difference_for_the_velocity(
    time_step = time_step,
    translation = translation,
    rotation = rotation
)

# Alternativluy, update everything manually
simulation.set_translation_only(translation)
simulation.set_rotation_only(rotation)

linear_velocity = [8.0, 0.0, 0.0]
angular_velocity = np.radians([0.0, 10.0, 0.0]).tolist()

simulation.set_velocity_linear(linear_velocity)
simulation.set_velocity_angular(angular_velocity)

</code></pre>
<h3 id="local-chord-angle-control"><a class="header" href="#local-chord-angle-control">Local chord angle control</a></h3>
<p>Updating the chord angles in the Python interface is done by set-method that takes a list of angles as input, that must have a length equal to the number of wings in the line force model. An example code snippet is shown below, for a case with three sails:</p>
<pre><code class="language-python">import numpy as np

# some code to set up the simulation, as above

simulation.set_local_wing_angles(
    np.radians([40.0, 35.0, 30.0]).tolist()
)
</code></pre>
<h3 id="update-the-internal-state"><a class="header" href="#update-the-internal-state">Update the internal state</a></h3>
<p>The internal state of the section models can be updated with a set method, similar to how the local wing angles can be updated. This is shown in the code example below:</p>
<pre><code class="language-python">import numpy as np

# some code to set up the simulation, as above

simulation.set_section_models_internal_state(
    np.radians([10, 12.5, 15]).tolist()
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="force-calculations"><a class="header" href="#force-calculations">Force calculations</a></h1>
<p>An important job for the line force model is to compute forces on each line element, as a function of the local flow variables. The results from these calculations are available in the result-structures from a simulation. A view of the result structure is shown as Rust code below. There is also a Python interface to this structure where the same fields are available.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SimulationResult {
    pub ctrl_points: Vec&lt;SpatialVector&lt;3&gt;&gt;,
    pub force_input: SectionalForcesInput,
    pub sectional_forces: SectionalForces,
    pub integrated_forces: Vec&lt;IntegratedValues&gt;,
    pub integrated_moments: Vec&lt;IntegratedValues&gt;,
    pub iterations: usize,
    pub residual: f64,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="sectional-vs-integrated"><a class="header" href="#sectional-vs-integrated">Sectional vs integrated</a></h2>
<p>The forces on a line force model is specified both as <em>sectional values</em> and as <em>integrated values</em>. As the name suggest, the sectional forces are forces acting on each individual section in the line force model. That is, the force acting on a single line element. The integrated forces and moments are the sum of sectional forces for each wing in the line force model. That is, the length of the integrated forces and moments vectors will be equal to the number of wings.</p>
<h2 id="force-types"><a class="header" href="#force-types">Force types</a></h2>
<p>There are four different force types in Stormbird, which are estimated from different methods. Each force type has a dedicated section below</p>
<h3 id="1---circulation-forces"><a class="header" href="#1---circulation-forces">1 - Circulation forces</a></h3>
<p>The first, and usually most important, force component is the force that arise from the circulation on each line segment. The circulation strength is estimated directly from the local velocity and sectional model, as described <a href="line_model/./circulation_strength.html">here</a>. The direction of the force is always normal to the local velocity.</p>
<p>The resulting force from the circulation strength is therefore just the "lift" on each line segment, but in the coordinate system of the local flow. Due to the presence of induced velocities, the sectional lift may cause both lift and drag relative to the incoming free stream. Circulation forces are, in other words, the combination of lift and lift-induced drag from the simulation.</p>
<h3 id="2---sectional-drag"><a class="header" href="#2---sectional-drag">2 - Sectional drag</a></h3>
<p>Sectional drag is, usually<sup class="footnote-reference" id="fr-sectional_drag_note-1"><a href="#footnote-sectional_drag_note">1</a></sup>, the viscous drag on each line segment. It is calculated directly from the drag function in the <a href="line_model/../sectional_models/sectional_models_intro.html">sectional model</a>. The direction is always parallel to the local flow.</p>
<h3 id="3---added-mass"><a class="header" href="#3---added-mass">3 - Added mass</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Added_mass">Added mass forces</a> are the forces that are proportional to the acceleration of the foil section. The magnitude of the force is determined by the added mass coefficients set in the sectional model and the acceleration. The foil-models only result in added mass forces due to acceleration in the direction normal to the chord vectors. For the rotating cylinder, the added</p>
<p><strong>Note</strong>: for now, the default value of the added mass coefficient is set to zero. This is because the feature is currently lacking a proper test case. Must therefore be used with care!</p>
<h3 id="4---gyroscopic"><a class="header" href="#4---gyroscopic">4 - Gyroscopic</a></h3>
<p>The gyroscopic force/moment is only applicable to rotor sails. It is the <a href="https://en.wikipedia.org/wiki/Precession">gyroscopic precision</a> due to the rotation of the cylinders. It is dependent on the 2D moment of inertia, which needs to be specified for the sectional model in order to make this force non-zero.</p>
<h2 id="force-results-structures"><a class="header" href="#force-results-structures">Force results structures</a></h2>
<p>To allow for a comparison between the force types - for instance in debugging situations - each force type is stored separately, in addition to the total force / moment. The structures used to store this data is shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SectionalForces {
    pub circulatory: Vec&lt;SpatialVector&lt;3&gt;&gt;,
    pub sectional_drag: Vec&lt;SpatialVector&lt;3&gt;&gt;,
    pub added_mass: Vec&lt;SpatialVector&lt;3&gt;&gt;,
    pub gyroscopic: Vec&lt;SpatialVector&lt;3&gt;&gt;,
    pub total: Vec&lt;SpatialVector&lt;3&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntegratedValues {
    pub circulatory: SpatialVector&lt;3&gt;,
    pub sectional_drag: SpatialVector&lt;3&gt;,
    pub added_mass: SpatialVector&lt;3&gt;,
    pub gyroscopic: SpatialVector&lt;3&gt;,
    pub total: SpatialVector&lt;3&gt;,
}
<span class="boring">}</span></code></pre></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-sectional_drag_note">
<p>It is perfectly fine to include more than the viscous drag in the sectional drag model, if, for instance, it is necessary to add some empirical corrections to the total drag estimate. What exactly the sectional drag represents from a purely physical point of view must be decided on when setting up the model by the user. <a href="#fr-sectional_drag_note-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="input-power"><a class="header" href="#input-power">Input power</a></h1>
<p>Some sail types, like rotor sail and suction sails require input power to operate. This is modeled entirely empirically in Stormbird. The structure that controls these models are shown below.</p>
<p>MORE TO COME ON THIS LATER</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InputPowerData {
    pub section_models_internal_state_data: Vec&lt;Float&gt;,
    pub input_power_coefficient_data: Vec&lt;Float&gt;,
}

pub enum InputPowerModel {
    NoPower,
    FromInternalStateAlone(InputPowerData),
    FromInternalStateAndVelocity(InputPowerData),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="section-models"><a class="header" href="#section-models">Section models</a></h1>
<p>The primary purpose of the sectional models is to compute non-dimensional lift and drag as a function of the local flow velocity at each each line element. That is, they are two-dimensional models which is used together with the chord vector and local flow velocity to compute the total force on each line section. In both lifting line and actuator line simulations, three-dimensional effects are modeled by altering the effective velocity experienced by these two-dimensional models.</p>
<p>Different sectional models are necessary for different sail types. This is handled by implementing the sectional model as an enum, with a definition as shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SectionModel {
    Foil(Foil),
    VaryingFoil(VaryingFoil),
    RotatingCylinder(RotatingCylinder),
}
<span class="boring">}</span></code></pre></pre>
<p>Each variant in this enum has its own sub-chapter for more details. A short overview is given below:</p>
<ol>
<li><code>Foil</code> represents a model for a single element foil profile, and is suitable for modelling single element wing sails</li>
<li><code>VaryingFoil</code> is a model that extends the <code>Foil</code> model to allow the output to be dependent on some internal variable. The internal variable can for instance be a flap angle, for a two-element foil, a combination of multiple element configurations, for instance to model a three-element foil, or suction rate when modelling a suction sail.</li>
<li><code>RotatingCylinder</code> represent a cylinder where the rotational speed can be varied to alter the force output. This is intended to be used to model rotor sails.</li>
</ol>
<p>More sectional models can be added in the future. The only requirement is that each model must be able to compute the necessary force coefficients. However, the goal is to cover most use cases with these three core models. Since the models are handled through an enum, they may require different inputs in their own functions for calculating lift and drag. For instance, the <code>Foil</code> and <code>VaryingFoil</code> models require the angle of attack as input, while the <code>RotatingCylinder</code> takes the velocity magnitude and local chord length (or diameter) as input. The right input is managed by the line force model structure, and is not something the user needs to think about when running a simulation.</p>
<p>To get an overview of how to set up the different variants, see the sub-chapters for each model.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foil-model"><a class="header" href="#foil-model">Foil model</a></h1>
<p>The <code>Foil</code> structure is a <em>parametric model</em> of a single element foil section. That is, it is defined using (relatively) few parameters that are later used in a simple mathematical model to compute lift and drag for arbitrary angles of attack.</p>
<h2 id="why-a-parametric-model"><a class="header" href="#why-a-parametric-model">Why a parametric model?</a></h2>
<p>Other implementations of lifting line and actuator line methods often use data based models for computing the lift and drag coefficients. That is, the user must supply data on how the lift and drag varies as a function of the angle attack, and then the solver can use this data together with interpolation or table look-up to compute force coefficients for arbitrary angles.</p>
<p>A data based approach is often fine, and does have some benefits. For instance, it is the only way to make a truly general model where the user have full control over the behavior of the sectional model. For this reason, there might be implementations of pure data based models in Stormbird in the future. However, the choice of using a parametric model for now where based on three reasons.</p>
<p>First, it becomes easier to use a parametric model as a building block for more complex foil models, where the behavior depends on some internal state, such as flap angle or suction rate. This is because the model parameters can be allowed to depend on the internal state through interpolation. See the <a href="sectional_models/./varying_foil_model.html">varying foil sub chapter</a> for more on this.</p>
<p>Second, a parametric model ensures smoothness, which is beneficial when using the model together with gradient based optimization algorithms. For instance, such a method might be used to optimize the angle of attack for wing sails at a given wind direction. The smoothness is in particular practical when the expected optimal point is close to the stall angle - which it often is.</p>
<p>Third, tuning a parametric models is generally believed to be easier than a data based model. For instance, lets say you want to adjust the exact stall characteristics of a 2D model, to make a simplified lifting line model better fit with high-fidelity experimental data; this would not be straightforward with a data based model, but should be fairly easy if the parametric model of the lift has good parameters to control the stall behavior.</p>
<p>The downside of a parametric model is believed to be small, as long as the model can represent typical foil section behavior without too many simplifications. The design of the <code>Foil</code> model is intended to achieve this as best as possible<sup class="footnote-reference" id="fr-update_to_model_note-1"><a href="#footnote-update_to_model_note">1</a></sup>.</p>
<h2 id="model-overview"><a class="header" href="#model-overview">Model overview</a></h2>
<p>The model is divided in two core sub-models, labeled <em>pre-stall</em> and <em>post-stall</em>, respectively representing the behavior before and after the foil has stalled due to too high angle of attack.</p>
<p>For angles of attack below stall, it is assumed that both lift and drag can be represented accurately with simple polynomials. The lift is linear by default, but can also have an optional high-order term where both the factor and power of the term is adjustable. The high order term is meant to capture slowly developing separations, which might occur at low Reynolds numbers. The drag is assumed to be represented as a second order polynomial. For a wing sail operating below stall, the drag will mostly be dominated by lift-induced drag forces. The viscous drag can therefore be kept simple, as the importance to the total force is relatively low.</p>
<p>For angles of attack above stall, both the lift and drag are assumed to be harmonic functions which primarily is adjusted by setting the <em>max value</em> after stall. This is a rough model which might not be perfect for all angles of attack, but is assumed to be close enough. A rough and approximate model for the post-stall behavior is assumed to be OK as wing sails and suction sails will most often operate below stall.</p>
<p>The transit between the two models is done using a <a href="https://en.wikipedia.org/wiki/Sigmoid_function">sigmoid function</a>, where both the transition point and the width of the transition can be adjusted.</p>
<p>In addition, there factors in the model to account for added mass and lift due to the time derivative of the angle of attack. Both these effects are assumed to be linear for simplicity.</p>
<h2 id="available-parameters"><a class="header" href="#available-parameters">Available parameters</a></h2>
<p>A view of the available fields in the <code>Foil</code> model is seen below, with further explanation of each parameter right after:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foil {
    pub cl_zero_angle: f64,
    pub cl_initial_slope: f64,
    pub cl_high_order_factor: f64,
    pub cl_high_order_power: f64,
    pub cl_max_after_stall: f64,
    pub cd_min: f64,
    pub angle_cd_min: f64,
    pub cd_second_order_factor: f64,
    pub cd_max_after_stall: f64,
    pub cd_power_after_stall: f64,
    pub cdi_correction_factor: f64,
    pub mean_positive_stall_angle: f64,.
    pub mean_negative_stall_angle: f64,
    pub stall_range: f64,
    pub cd_bump_during_stall: f64,
    pub cd_stall_angle_offset: f64,
    pub added_mass_factor: f64,
}
<span class="boring">}</span></code></pre></pre>
<p>An explanation of the parameters are given below:</p>
<ul>
<li><code>cl_zero_angle</code>: Lift coefficient at zero angle of attack. This is zero by default, but can be set to a non-zero value to account for camber, flap angle or boundary layer suction/blowing.</li>
<li><code>cl_initial_slope</code>: How fast the lift coefficient increases with angle of attack, when the angle of attack is small. The default value is \( 2 \pi \) , which should always be the values used for a normal foil profile - with or without camber and flap - but it can also be set to different value for instance to account for boundary layer suction/blowing.</li>
<li><code>cl_high_order_factor</code>: Optional proportionality factor for adding higher order terms to the lift. Is zero by default, and therefore not used. Can be used to adjust the behavior of the lift curve close to stall.</li>
<li><code>cl_high_order_power</code>: Option power for adding higher order terms to the lift. Is zero by default, and therefore not used. Can be used to adjust the behavior of the lift curve close to stall.</li>
<li><code>cl_max_after_stall</code>: The maximum lift coefficient after stall.</li>
<li><code>cd_min</code>: Minimum drag coefficient when the angle of attack is equal to the <code>angle_cd_min</code>.</li>
<li><code>angle_cd_min</code>: The angle where the the minimum drag coefficient is reached.</li>
<li><code>cd_second_order_factor</code>: Factor to give the drag coefficient a second order term. This is zero by default.</li>
<li><code>cd_max_after_stall</code>: The maximum drag coefficient after stall.</li>
<li><code>cd_power_after_stall</code>: Power factor for the harmonic dependency of the drag coefficient after stall. Set to 1.6 by default.</li>
<li><code>cdi_correction_factor</code>: factor that can be used to correct for numerical errors in the lift-induced drag. Set to a positive value to increase the drag, and a negative value to decrease the drag. The default is zero, which means no correction.</li>
<li><code>mean_positive_stall_angle</code>: The mean stall angle for positive angles of attack, which is the mean angle where the model transitions from pre-stall to post-stall behavior. The default value is 20 degrees.</li>
<li><code>mean_negative_stall_angle</code>: The mean stall angle for negative angles of attack, which is the mean angle where the model transitions from pre-stall to post-stall behavior. The default value is 20 degrees.</li>
<li><code>stall_range</code>: The range of the stall transition. The default value is 6 degrees.</li>
<li><code>cd_bump_during_stall</code>: Factor to model additional drag when the foil is stalling, but that is not included in the pre- and post-stall drag models. Set to zero by default.</li>
<li><code>cd_stall_angle_offset</code>: Optional offset to the stall angle for the drag coefficient. This can be used to tune the drag curve to better fit experimental data. The default is zero, which means that stall effects on the drag starts at the same angle of attack as for the lift. When the offset is set to any value, the "amount of stall" function is shifted by this value for the case of the drag coefficient only.</li>
<li><code>added_mass_factor</code>: Factor to model added mass due to accelerating flow around the foil. Set to zero by default.</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>An example of the output of a foil model is shown below. The parameters values are given as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foil = Foil {
    cl_zero_angle = 0.5,
    cl_max_after_stall = 0.9,
    cd_max_after_stall = 1.2,
    mean_positive_stall_angle = 20.0_f64.to_radians(),
    mean_negative_stall_angle = 25.0_f64.to_radians(),
    stall_range = 10.0_f64.to_radians(),
    ..Default::default()
}

<span class="boring">}</span></code></pre></pre>
<p><img src="sectional_models/figures/foil_model_example.png" alt="Foil model example" /></p>
<hr>
<ol class="footnote-definition"><li id="footnote-update_to_model_note">
<p>The design of the <code>Foil</code> model is open for changes, and may be updated when a need is discovered. The goal is to find the right balance between simplicity and flexibility. <a href="#fr-update_to_model_note-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="varying-foil-model"><a class="header" href="#varying-foil-model">Varying foil model</a></h1>
<p>The <code>VaryingFoil</code> structure is a model of a foil where the output can be allowed to depend on some internal state. The typical example is a flap angle, for a two-element foil, or suction rate, for a suction sail. To achieve this, the varying foil model uses multiple <code>Foil</code> models, each belonging to a specific internal value. Linear interpolation is used for all <code>Foil</code> model parameters for each state between the input data. This interpolation is handled by the <code>VaryingFoil</code> structure whenever a new internal state is set.</p>
<h2 id="how-to-setup-a-varyingfoil-structure"><a class="header" href="#how-to-setup-a-varyingfoil-structure">How to setup a VaryingFoil structure</a></h2>
<p>As a general case, you need to tune several <code>Foil</code> models for multiple values of whatever you want to use as an internal state of the wing. If this is a flap angle, you would need data for the lift and drag coefficients as a function of angles of attack for multiple discrete flap angles. When a unique model is generated for each value of the flap angle, this can be given as input to the <code>VaryingFoil</code> structure, along with the flap angle data as <code>internal_state_data</code>. An example will come...</p>
<h2 id="what-if-i-want-to-model-a-three-element-foil"><a class="header" href="#what-if-i-want-to-model-a-three-element-foil">What if I want to model a three-element foil?</a></h2>
<p>More complex models with more internal variable might be added in the future. This will be done when the use case represent itself, and likely not before. However, it is still possible to use the <code>VaryingFoil</code> structure to model sails with more control parameters in a slightly simplified way.</p>
<p>For instance, lets assume you want to model a three-element foil, where there is both a flap and a leading edge slot. Currently it is not possible to model changing values of the slot- and flap-angle independently directly in Stormbird. However, if you assume some relationship between the flap angle and the slot angle, the <code>VariableFoil</code> structure can still be used.</p>
<p>This might not be such a large simplification for practical use cases<sup class="footnote-reference" id="fr-more_investigation_note-1"><a href="#footnote-more_investigation_note">1</a></sup>. The point of a multi-element foil is both to create larger maximum lift forces and to reduce the drag force for a given lift force. In a lifting line model - and also mostly for wings in general - the lift-induced velocities are not very affected by <em>how</em> the lift is created. Rather, it is just the value of the lift-coefficient that matters. For a given <em>wanted lift coefficient</em> it seems reasonable that there is always a single optimum combination of flap- and slot-angle, which <em>probably</em> can be computed independently of three-dimensional effects. As such, reducing the model to a single internal variable <em>might</em> not be a big problem.</p>
<h2 id="available-parameters-1"><a class="header" href="#available-parameters-1">Available parameters</a></h2>
<p>The available parameters in the structure is shown below.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct VaryingFoil {
    pub internal_state_data: Vec&lt;f64&gt;,
    pub foils_data: Vec&lt;Foil&gt;,
    pub current_internal_state: f64,
}
<span class="boring">}</span></code></pre></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-more_investigation_note">
<p>This is currently a hypothesis which we hope to be able to explore more in the future... <a href="#fr-more_investigation_note-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="rotating-cylinder"><a class="header" href="#rotating-cylinder">Rotating cylinder</a></h1>
<p>Model representing a rotating cylinder, where the main intended use case is to model rotor sails. The purpose is to calculate lift, drag on a two-dimensional cylinder as a function of how fast the cylinder is spinning.</p>
<p>The primary input variable to the model is the <em>spin ratio</em>, which is defined as the ratio of the velocity of the rotor to the wind velocity. The velocity of the rotor is defined as the circumference times the rotations per seconds.</p>
<p>Unlike the <a href="sectional_models/foil_model.html">foil model</a>, the rotating cylinder model is entirely data based and not parametric. There are primary two reasons for this:</p>
<ol>
<li>The behavior of lift and drag on a spinning cylinder is, in some ways, simpler than a foil section. The lift will generally increase with increasing spin-ratios, and not experience stall in the same way as a foil. In addition, the two-dimensional drag is generally going from a high value at zero spin-ratio to a very low value at normal operating spin-ratios. A few data points are therefore often enough to capture the behavior of a rotating cylinder.</li>
<li>It is not common, at least not yet, to combine a rotating cylinder with other control mechanism. For instance, for wing sails and suction sails it is common to control the sails with both a flap angle or suction rate, and the angle of attack. A rotor sail is only controlled through its rotational speed. A simple one dimensional data model is therefore assumed to be sufficient for rotor sails (lift and drag as function of spin ratio only)</li>
</ol>
<h2 id="available-parameters-2"><a class="header" href="#available-parameters-2">Available parameters</a></h2>
<p>The parameters in the rotating cylinder are listed below.</p>
<p>The <code>cl_data</code>, <code>cd_data</code> and <code>spin_ratio_data</code> is the most important parts of the model. They specify how lift and drag is dependent on the spin ratio. All variables have default variables based on the results in the article "<a href="https://blueoasis.pt/wp-content/uploads/2023/10/Nutts2023_proceedings_v4.pdf">Calculation of Flettner rotor forces using lifting line and CFD methods</a>". See also the <a href="sectional_models/../literature/validation_data.html">validation data section</a> for more on this.</p>
<p>The <code>added_mass_factor</code> and <code>moment_of_inertia</code> parameters can be used to estimate added mass forces and gyroscopic forces on the rotor. <strong>Note</strong>: more to come on these parameters later. They need further validation, and are therefore set to zero by default.</p>
<p>The spin ratio for each section is calculated based on the <code>revolutions_per_second</code> value and the local chord length and velocity. Then, the lift and drag in 2D is interpolated from the input data values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RotatingCylinder {
    pub revolutions_per_second: f64,
    pub spin_ratio_data: Vec&lt;f64&gt;,
    pub cl_data: Vec&lt;f64&gt;,
    pub cd_data: Vec&lt;f64&gt;,
    pub added_mass_factor: f64,
    pub moment_of_inertia_2d: f64,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifting-line-simulations"><a class="header" href="#lifting-line-simulations">Lifting line simulations</a></h1>
<p>The basics of the lifting line simulations in Stormbird have a lot in common with the classical approaches made by Lanchester (1907) and Prandtl (1918) more than 100 years ago, and which are also often taught in many introduction courses for fluid dynamics and lifting surfaces (e.g., the text books in the <a href="lifting_line/../literature/simulation_methods.html">literature chapters</a>). That is, the overall concept and equations is the same. The wing geometry is reduced to vortex lines along the span, the lift and circulation on the line elements are estimated from the local velocity and angle of attack based on a two-dimensional sectional model, and the lift-induced velocities due to the estimated circulation is calculated based on a potential theory wake model.</p>
<p>However, the Stormbird implementation also differs from the classical lifting line approach in at least three broad-stroke ways, explained further in the subsections below</p>
<h2 id="non-linear-solver"><a class="header" href="#non-linear-solver">Non-linear solver</a></h2>
<p>In the classical lifting line method, the circulation is found by solving a <em>simplified linearized equation system</em>. The system is based on the assumptions that the lift-induced velocities are small and that there is a linear relationship between the lift and vertical induced velocities on the wing. As a consequence, only a single equations system must be solved for each free stream condition, which makes the solution fast and simple.</p>
<p>The big problem with this type of solver in the context of wind propulsion devices is that the final solution does not include viscous effects on the lift. Viscous effects are, for instance, important when wing sails or suction sails are operated close to stall. In addition, the assumption about small lift-induced velocities may not be correct for high-lift wind propulsion types, such as rotor- and suction sails.</p>
<p>Stormbird solves for the circulation strength in ways that attempt to capture the viscous effects in physical correct ways. That is, a stalled wing section affect both the forces and the lift-induced velocities from the wing. At the moment, there are two solvers. The first is based on the original linearized equations system, but with a post-solver empirical correction to account for viscose effects on each section. The second is a based on and iterative non-linear solver, which is mathematically more correct when the lift-induced velocities becomes large. However, with the right tuning of the model, both solvers can generally find a good solution.</p>
<p>More details is given in the <a href="lifting_line/solver.html">solver chapter</a></p>
<h2 id="arbitrary-shaped-wings"><a class="header" href="#arbitrary-shaped-wings">Arbitrary shaped wings</a></h2>
<p>The classical methods assumes that both the wing and the wake is completely flat, and that the potential theory vortex wake extends indefinitely far downstream of the wing. These are necessary assumptions to develop an analytical equation system. However, they are not necessary when solving the equations numerically.</p>
<p>As already explained in the <a href="lifting_line/./../line_model/line_model_intro.html">line model chapter</a>, simulation models are built up of several discrete line elements. This makes it possible to have arbitrary shaped wings, and have multiple wings together in the same simulations. To make this possible in a lifting line simulation, it is necessary with some way to calculate <em>induced velocities</em> from a line element. This is done by assuming that each line line element is a <em>constant strength vortex line</em>.</p>
<p>Such vortex lines are also often used in panel methods or vortex lattice methods to represent <em>doublet panels</em>. The exact formulation for the induced velocity as a function of line geometry and strength are taken from the <a href="lifting_line/../literature/simulation_methods.html#vsaero-theory-document-1987">VSAERO theory document</a></p>
<h2 id="unsteady-simulations-and-dynamic-wakes"><a class="header" href="#unsteady-simulations-and-dynamic-wakes">Unsteady simulations and dynamic wakes</a></h2>
<p>The final extension from the classical lifting line approach is the inclusion of dynamic wakes and unsteady modeling. This means that the wings can move during a simulation, and the velocity input can change as a function of time.</p>
<p>Unsteady simulations comes in two flavors: 1) <strong>quasi-steady</strong> and 2) <strong>dynamic</strong>. In the quasi-steady case, the wake is as it is in a conventional lifting line simulation: It consist of <em>horseshoe</em> vortices that extend far downstream from the span lines of each wing for every time step. However, unsteady behavior is still modeled by changes in the <em>felt velocity</em> at the line elements due to the motion of the wings or changes in the freestream input.</p>
<p>In the dynamic case, the wake modeled is extended to consist of many doublet panels, similar to how it would be in an unsteady panel- or vortex lattice method. Both the strength and the shape of the wake panels will vary as a function of time, which allows for proper dynamic modeling of the lift. That is, the lift-induced velocities depend not only on the current <em>state</em> of the line model, but also the history of previous states.</p>
<p>For a single conventional wing, the shape of the vortex wake is typically not that important, which is why is often assumed to be flat in simplified methods. However, we have found that this is not necessarily the case when the lift coefficient becomes very high - such as for rotor sails - or when several sails are placed so close together at the wakes get strongly deformed by other wings. When running dynamic simulations, the shape of the wake can be modified by the induced velocities in the simulation<sup class="footnote-reference" id="fr-note-1"><a href="#footnote-note">1</a></sup>. This can also be used to simulate steady cases where a detailed wake shape is of interest.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>Lanchester, F. W., 1907. Aerodynamics: Constituting the First Volume of a Complete Work on Aerial Flight</li>
<li>Prandtl, L., 1918. Tragflügeltheorie. Königliche Gesellschaft der Wissenschaften zu Göttingen.</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-note">
<p>It is also possible to turn this of to increase the computational speed. See the <a href="lifting_line/./wake_builders.html">wake builders section</a> for more <a href="#fr-note-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="simulation-overview"><a class="header" href="#simulation-overview">Simulation overview</a></h1>
<p>Lifting line simulations in Stormbird are managed and executed through a specialized <code>Simulation</code> structure. The responsibility of this structure is to store and update the data necessary for a simulation. It can be executed once, for steady-state conditions, or for many time steps, in dynamic conditions. When executed many times, the results from the previous time steps are used as initial conditions for the next time steps.</p>
<h2 id="creating-a-simulation"><a class="header" href="#creating-a-simulation">Creating a simulation</a></h2>
<p>To construct a <code>Simulation</code>, a <code>SimulationBuilder</code> is used. An overview of the fields in the builder is shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SimulationBuilder {
    pub line_force_model: LineForceModelBuilder,
    pub simulation_settings: SimulationSettings,
}
<span class="boring">}</span></code></pre></pre>
<p>The only input that is absolutely necessary to specify is the <a href="lifting_line/./../line_model/building_line_model.html">builder for a line force model</a>. The simulation settings structure have default variables.</p>
<p>Simulations in Python are created through a <code>Simulation</code> class that takes a JSON string containing the  data for the <code>SimulationBuilder</code>.</p>
<pre><code class="language-python">from pystormbird.lifting_line import Simulation
import json

# Some code to generate setup string before this for both the line force model
# and the simulation settings.

setup_dict = {
    "line_force_model": line_force_model_dict,
    "simulation_settings": simulation_settings_dict
}

simulation = Simulation(
    setup_string = json.dumps(setup_dict)
)
</code></pre>
<h2 id="simulation-settings"><a class="header" href="#simulation-settings">Simulation settings</a></h2>
<p>The simulation settings is an Enum that specifies whether the simulation should be executed using the quasi-steady or the dynamic variant of the lifting line. Each variant includes its own settings, which gives the necessary input to each method. The point of collecting both methods into the same structure is to generate an interface where the same line force model can easily be executed in the same way using both methods. This is, for instance useful for comparison cases.</p>
<p>The Enum looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SimulationSettings {
    QuasiSteady(QuasiSteadySettings),
    Dynamic(DynamicSettings),
}
<span class="boring">}</span></code></pre></pre>
<p>Both the <code>QuasiSteadySettings</code> and the <code>DynamicSettings</code> have the same general fields: one structure for the <a href="lifting_line/./solver.html">solver</a> and another for the <a href="lifting_line/./wake.html">wake</a>. The actual rust definition looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QuasiSteadySettings {
    pub solver: QuasiSteadySolverBuilder,
    pub wake: QuasiSteadyWakeSettings,
}

pub struct DynamicSettings {
    pub solver: Solver,
    pub wake: DynamicWakeBuilder,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="running-a-simulation"><a class="header" href="#running-a-simulation">Running a simulation</a></h2>
<p>Executing a simulation after a <code>Simulation</code> structure is made is done with a function called <code>do_step</code>. On the Rust side, it has the following signature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_step(
    &amp;mut self,
    time: f64,
    time_step: f64,
    freestream_velocity: &amp;[SpatialVector]
) -&gt; SimulationResult
<span class="boring">}</span></code></pre></pre>
<p>The input is the current time, time step, and an a vector containing the freestream velocity at all relevant points for the model. See the <a href="lifting_line/./velocity_input.html">velocity input section</a> for more on how this vector is defined and how to generate it.</p>
<p>On the Python side, the same function looks like this <sup class="footnote-reference" id="fr-note1-1"><a href="#footnote-note1">1</a></sup>:</p>
<pre><code class="language-python">def do_step(
    self,
    *,
    time: float,
    time_step: float,
    freestream_velocity: list[list[float]],
) -&gt; SimulationResult
</code></pre>
<p>That is, the python code takes in the same input as the Rust side, but with the equivalent Python data structures. The <code>SpatialVector</code> input is actually just a wrapper around an array with three elements, representing the velocity components in x, y, and z orientation. On the Python side, one can pass in a list with many three-elements sub-lists that will be converted to <code>SpatialVectors</code> inside the Python wrapper function before being passed to the Rust code.</p>
<p>If the simulation is executed using the quasi-steady approach, the time step will not generally affect the results <sup class="footnote-reference" id="fr-note2-1"><a href="#footnote-note2">2</a></sup>. That means that a steady simulation can be executed by running a quasi-steady simulation only once.</p>
<p>The return from each time step is a <a href="lifting_line/./../line_model/force_calculations.html">SimulationResult</a>. This structure has a Python implementation as well, with some minor helper methods to interpret the results.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-note1">
<p>The actual implementation is actually written slightly different as it is written in Rust and uses PyO3 to generate the Python interface. However, the code shown represents how it would have look like if it were written as Python code directly. <a href="#fr-note1-1">↩</a></p>
</li>
<li id="footnote-note2">
<p>This is only true for the first time step. It will never affect the circulatory lift, but it may add forces from added mass effects and dynamic rotation effects on the foil, if these effects are turned on. They are not turned on by default, though. In addition, these effects are always turned off for the first time step, as no motion history is available. That is, the acceleration and translation and rotation velocity is always assumed to be zero at the first time step. <a href="#fr-note2-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="solver"><a class="header" href="#solver">Solver</a></h1>
<p>The job of the lifting line solver is to find the right circulation strength on the wing for the given state, i.e., the freestream velocity and the motion at the current time step. The challenge lies in the dependency between the circulation strength and the <em>induced velocities</em>. Changing the strength also changes the lift-induced velocities from the the potential theory wake, which means that the strength must be <em>solved for</em>, not just calculated.</p>
<p>To solvers currently exists: a linearized solver with viscous corrections and a full non-linear solver based on dampened iterations.</p>
<h2 id="linearized-solver-with-a-simple-viscous-correction"><a class="header" href="#linearized-solver-with-a-simple-viscous-correction">Linearized solver with a simple viscous correction</a></h2>
<p>The linearized solver creates an equation system like the original lifting line method. The lift-induced velocities are assumed to only affect the angle of attack and the lift as a function of angle of attack is assumed to be linear. More in depth explanations may be found in text books like Anderson (2005).</p>
<p>The result of applying the normal lifting line assumptions is a linear equation system that can be solved using a conventional linear algebra solver. The linearized solver therefore works by first setting up the equation system as a matrix and a right-hand side vector, before solving it using conventional Gaussian elimination.</p>
<p>However, the <strong>procedure above is only the first step</strong>. Due to the assumption of linear lift as a function of angle of attack, the resulting circulation that is returned from the solver is without any stall- or other non-linear effects on the lift. To account for this, a simplified viscous correction methods is applied after solving for the circulation strength using a linear solver. It consists of the following steps:</p>
<ol>
<li>Calculate the lift-induced velocities and resulting effective angle of attack with the solved circulation strength</li>
<li>Calculate the lift both with a linearized sectional model and the full sectional model, including stall effects</li>
<li>Correct the solved circulation strength by multiplying it with the full lift and dividing it by the linearized lift</li>
<li>Recalculate lift-induced velocities and effective angles of attack for the final force calculations</li>
</ol>
<p>This solver is found to work fine for <strong>quasi-steady</strong> cases, but do also tend to predict <strong>stall at a larger angle of attack</strong> than the full non-linear solver below. However, the stall-issue can be handled by tuning the stall behavior of the sectional model to 3D data of a single sail. For quasi-steady cases it will be significantly faster than running the full non-linear solver described in the next section, and is therefore set to the default solver for such cases.</p>
<h2 id="non-linear-solver-using-damped-iterations"><a class="header" href="#non-linear-solver-using-damped-iterations">Non-linear solver using damped iterations</a></h2>
<p>The second solver is inspired by a simple approach outlined in <a href="lifting_line/../literature/simulation_methods.html#fundamentals-of-aerodynamics-2005">Anderson (2005), chapter 5.4</a>. The basic principle is to start with a first guess of the circulation distribution and then slowly update the values based on iterative calculations of the lift-induced velocities. In short, for every iteration of a lifting line solver, the following is calculated:</p>
<ol>
<li>The lift-induced velocities from the <a href="lifting_line/wake.html">wake model</a>, where the circulation strength from the last iteration (or initial guess, if it is the first iteration) is used as input to the wake model.</li>
<li>A new estimation of the <a href="lifting_line/./../line_model/circulation_strength.html">circulation strength on the line force model</a> with the current estimate of the lift-induced velocities as input.</li>
<li>An updated circulation strength for the next iteration which is based on a mix between the current circulation strength and the new estimated value, controlled by a damping factor.</li>
</ol>
<p>To write step 3 as an equation: The circulation strength at the iteration \( i \) is called \( \Gamma_i \). The previous circulation strength is called \( \Gamma_{i-1} \), and the circulation strength that is calculated using the current estimation of lift-induced velocities is called \( \Gamma_{i, estimated} \). With a damping factor labeled \(d \), the relationship between these values are as follows:</p>
<p>\[
\Gamma_i = \Gamma_{i-1} + d (\Gamma_{i, estimated} - \Gamma_{i-1})
\]</p>
<p>The benefit of this solver is that it is simple and techncially more correct than the linearized solver, as there are no assumptions about small lift-induced velocities. It will also handle non-linear effects on the lift directly, without any post-solver corrections, like in the case for the linearized solver. It is generally robust <strong>if the damping factor is set low enough</strong>, but may also give noise in the final results right at the stall point in some cases. This is typically handled by applying some <a href="lifting_line/../line_model/circulation_strength.html">smoothing to the circulation strength</a> in the line force model. It is also the <strong>most suitable solver for unsteady simulations</strong>, which typically do not require many iterations for each time step, as the change in the circulation strength is small.</p>
<h2 id="residual-damping-factor-and-convergence-testing"><a class="header" href="#residual-damping-factor-and-convergence-testing">Residual, damping factor, and convergence testing</a></h2>
<p>The residual is a measure on how close the solver is to the <em>correct solution</em>. It is calculated from the difference in the lift coefficient on each line element with the current best guess of the circulation distribution, \( \Gamma_i \) from the equations above, and the lift coefficient directly from the <a href="lifting_line/./../sectional_models/sectional_models_intro.html">sectional model</a> using the current estimated lift-induced velocities. That is, this will also be the same as the lift coefficient calculated with the current estimated circulation distribution, or \( \Gamma_{i, estimated} \) from the equations above.</p>
<p>As an equation, the residual, \(r\), for a line element is calculated as follows, where \(C_L(\Gamma) \) is the lift coefficient based on the induced velocities due to \( \Gamma \):</p>
<p>\[
r_i = C_L(\Gamma_{i}) - C_L(\Gamma_{i, estimated})
\]</p>
<p>The value of this residual <em>should</em> go towards zero with successive iterations. Since the value is calculated from the lift-coefficients, it is not dependent on the geometrical dimensions or the freestream velocity. The solver will stop if the value of the residual goes below the <code>residual_tolerance_absolute</code> value in the <code>SolverSettings</code> below.</p>
<h2 id="solver-settings"><a class="header" href="#solver-settings">Solver settings</a></h2>
<p>The source code below show the available fields for the lifting line solver settings. For quais-steady cases, a <strong>builder</strong> is used to set the right settings for this application area</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Solver {
    SimpleIterative(SimpleIterative),
    Linearized(Linearized)
}

pub enum QuasiSteadySolverBuilder {
    SimpleIterative(QuasiSteadySimpleIterativeBuilder),
    Linearized(Linearized)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="linearized-settings"><a class="header" href="#linearized-settings">Linearized settings</a></h3>
<p>For the linearized settings, the following source code show the available fields:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Linearized {
    pub velocity_corrections: VelocityCorrections,
    pub disable_viscous_corrections: bool,
    pub induced_velocity_correction_method: InducedVelocityCorrectionMethod
}
<span class="boring">}</span></code></pre></pre>
<p>The only one that could be interesting to modify is the <code>VelocityCorrections</code>. They are explained in its own section below. The other two are mainly for testing purposes and not necessary to adjust for normal use cases.</p>
<h3 id="non-linear-settings"><a class="header" href="#non-linear-settings">Non-linear settings</a></h3>
<p>For the non-linear settings, the following source code show the available fields:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SimpleIterative {
    pub max_iterations_per_time_step: usize,
    pub damping_factor: f64,
    pub residual_tolerance_absolute: f64,
    pub strength_difference_tolerance: f64,
    pub velocity_corrections: VelocityCorrections,
    pub start_with_linearized_solution: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>QuasiSteadySimpleIterativeBuilder</code> used when building a solver for quasi-steady cases is in general a structure with the same fields, but with different default settings that is more suitable for steady cases.</p>
<p>An explanation of each field is given below:</p>
<ul>
<li><code>max_iterations_per_time_step</code>: This parameter control how many iterations that will be performed <strong>per time step</strong>. That is, if a steady simulation is executed, which generally only runs one time step, it is also the max total number of iterations. The solver might stop before the max number of iterations is reached, if the <code>convergence_test</code> structure gives a positive test on a converged solution. The default values for this parameter depends on the simulation mode. In a dynamic case, it is 20 (<em>which might be excessive... should be tested more</em>). In a quasi-steady case it is 1000 (<em>definitely excessive most of the time, but the convergence test will generally make the solver stop long before this</em>)</li>
<li><code>damping_factor</code>: Determines how fast the circulation distribution should be updated as explained in the <em>iterative damped iterations</em> section above. This value must be specified and is set to 0.05 as default when using a steady wake, and 0.1 when using an unsteady wake.</li>
<li><code>residual_tolerance_absolute</code>: A value used to determine when the solution is converged based on the residual.</li>
<li><code>strength_difference_tolerance</code>: A value used to determine when the solution is converged based on the maximum difference butene the previous and next estimated circulation strength.</li>
<li><code>velocity_corrections</code>: An option to add corrections to the estimated velocity, to handle singularities and difficult cases.</li>
<li><code>start_with_linearized_solution</code>: A boolean that can be set to true if you want the first iteration to estimate the circulation distribution using a linear solver. The rest of the iterations will then use the normal non-linear iterations to update from the linearized solver.</li>
</ul>
<h2 id="velocity-corrections"><a class="header" href="#velocity-corrections">Velocity corrections</a></h2>
<p>Velocity corrections are special models that can be used to alter the resulting lift-induced velocities computed from the circulation distributions in the solvers. The purpose is two-fold. For one, applying corrections to the lift-induced velocities may stabilize the solver. Second, the velocity corrections may be used to correct for physical effects that are not directly part of the line force model model such as end-disks. The drag on rotor sails, in particular, may be estimated to be too high compared to values estimated with high-fidelity CFD simulations without some corrections applied to the lift-induced velocities, which is likely due to the presence of the large end-disks on such sails.</p>
<p>The velocity corrections are represented by en enum that looks like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum VelocityCorrections {
    #[default]
    NoCorrection,
    MaxInducedVelocityMagnitudeRatio(f64),
    FixedMagnitudeEqualToFreestream,
}
<span class="boring">}</span></code></pre></pre>
<p>The default is to use no corrections, so that the lift-induced velocities from the solver is calculated based on the raw circulation strength. Then there are two correction methods to chose from:</p>
<ul>
<li><code>MaxInducedVelocityMagnitudeRatio</code> makes sure the lift-induced velocity magnitude never exceeds a ratio of the freestream velocity. The ratio is supplied as an input. A typical value could be to set the ratio to 1.0, which would be the same as saying that the lift-induced velocity should never exceed the freestream magnitude.</li>
<li><code>FixedMagnitudeEqualToFreestream</code> computes a velocity vector based on the raw lift-induced velocity and the freestream that is limited in magnitude to the freestream velocity but allowed to rotate freely. That is, this correction allows the lift-induced velocity to change the orientation of the effective velocity at each line segment, but not the magnitude. This can, for instance, be used to force the non-linear solver to behave more like a linear solver.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifting-line-wake"><a class="header" href="#lifting-line-wake">Lifting line wake</a></h1>
<p>The vortex wakes from the wings are the most important part of a lifting line simulation. They are responsible for modeling how the velocity is affected by the wings themselves. How the velocity should be calculated depends on a several settings variables. Setting up a wake model is therefore done using "wake builders" which both contain settings used directly by the final wake structures and settings used for initializing the wake structures. An overview of the fields available in the wake builders are given in this section.</p>
<h2 id="internal-wake-data"><a class="header" href="#internal-wake-data">Internal wake data</a></h2>
<p>Inside a simualtion structure, the wake is representing as a <code>WakeData</code> structure that looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum WakeData {
    Dynamic(DynamicWake),
    QuasiSteady(QuasiSteadyWakeSettings),
}
<span class="boring">}</span></code></pre></pre>
<p>That is, the exact nature of the data depends on whether the wake is quasi-steady or dynamic.</p>
<p>In the case of a dynamic case, the wake is represented as many panels where both the strength and position may evolve over time. In the case of the quasi-steady case, the wake is just a set of horseshoe vortices where the trailing vortices are following the freestream. The quasi-steady wake representation is much faster, but also limited in accuracy as it cannot model the full dynamic variations in the lift-induced velocities.</p>
<h2 id="quasi-steady-wake-settings"><a class="header" href="#quasi-steady-wake-settings">Quasi-steady wake settings</a></h2>
<p>The quasi-steady wake is constructed on the fly for every time step with the following settings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QuasiSteadyWakeSettings {
    pub wake_length_factor: f64,
    pub symmetry_condition: SymmetryCondition,
    pub viscous_core_length: ViscousCoreLength,
}
<span class="boring">}</span></code></pre></pre>
<p>All of the fields have default settings. The <code>wake_length_factor</code> determines how long each trailing vortex should be, as a ratio of the chord length of the wings. It has a default value of 100.0.</p>
<p>The symmetry condition structure specifies if any form of symmetry should be assumed when calculating the lift-induced velocities. The default is no symmetry, but symmetry can also be turned on in x, y, and z direction through setting different values in the Enum.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SymmetryCondition {
    #[default]
    NoSymmetry,
    X,
    Y,
    Z,
}
<span class="boring">}</span></code></pre></pre>
<p>The value of the lift-induced velocity will go to infinity, according to potential theory, if one tries to evaluate it too close to the vortex line. This may cause issues in cases where vortex lines from one wing is potentially colliding with another. To handle such problems, Stormbird uses a viscous correction on the lift-induced velocity. When this correction should be applied is determined by a <code>ViscousCoreLength</code> structure. The value can be specified either as a value relative to the bound vortex length, or as an absolute value. This is handled by the enum below. <code>NoViscousCore</code> turns of the viscous core length. <strong>Tip: turning it off may significantly speed up a simualtion</strong>, but may also cause instabilities if multiple sails are present. The default value is <code>Relativ(0.1)</code>, which means that the viscous core length will be 10% of the bound vortex.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ViscousCoreLength {
    Relative(f64),
    Absolute(f64),.
    NoViscousCore,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="dynamic-wake-builder"><a class="header" href="#dynamic-wake-builder">Dynamic wake builder</a></h2>
<p>The settings for building a dynamic wake is shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DynamicWakeBuilder {
    pub nr_panels_per_line_element: usize,
    pub viscous_core_length: ViscousCoreLength,
    pub viscous_core_length_evolution: ViscousCoreLengthEvolution,
    pub first_panel_relative_length: f64,
    pub last_panel_relative_length: f64,
    pub use_chord_direction: bool,
    pub ratio_of_wake_affected_by_induced_velocities: f64,
    pub far_field_ratio: f64,
    pub shape_damping_factor: f64,
    pub neglect_self_induced_velocities: bool,
    pub initial_relative_wake_length: f64,
    pub write_wake_data_to_file: bool,
    pub wake_files_folder_path: String,
}
<span class="boring">}</span></code></pre></pre>
<p>All values have default values which should make sense in most situations. The most common variable to adjust will be <code>nr_panels_per_line_element</code>, the <code>write_wake_data_to_file</code>, and the <code>wake_files_folder_path</code>. The first determines the number of panels in the streamwise direction. The two second variables are used if you want to export the wake panels to a files for visualizations. If <code>write_wake_data_to_file</code> is set to true, the wake panels will be exported as <code>.vtk</code> files to the folder defined by the <code>wake_files_folder_path</code> string.</p>
<p>For the rest of the variables, see the explanation in the <a href="https://docs.rs/stormbird/0.7.0/stormbird/">code documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="velocity-input"><a class="header" href="#velocity-input">Velocity input</a></h1>
<p>As shown in the <a href="lifting_line/./simulation_overview.html">simulation overview section</a>, to simulate a single time step using the lifting line methods, it is necessary to call the <code>do_step</code> function with a vector (in Rust) or list (in Python) of three dimensional spatial vectors as input. This input is labeled the <code>freestream_velocity</code>, and represents the freestream velocity at all <strong>relevant points</strong> in the lifting line simulation.</p>
<p>Which points this is depends on the type of simulation. For the quasi-steady cases, it is only the control points of the line force model, as the wake downstream of the wings are not affected by local velocities. For the dynamic simulation it is both the control points and the wake points, as the wake shape is integrated from the velocity field.</p>
<h2 id="why-spatial-varying-input"><a class="header" href="#why-spatial-varying-input">Why spatial varying input?</a></h2>
<p>The point of specifying the velocity at each of these points individually is that this opens up for models that supply spatially varying velocity fields to the simulations. This can for instance be used to incorporate the following things in the simulation:</p>
<ul>
<li><strong>Atmospheric boundary layers model:</strong> The wind speed - and potentially also direction - will vary depending on the height above the ocean. A simplified model of the atmospheric boundary layer can be used to generate different velocities for each relevant point. At the moment this must be specified by the user <sup class="footnote-reference" id="fr-model_note-1"><a href="#footnote-model_note">1</a></sup>.</li>
<li><strong>Simplified models of viscous wakes:</strong> The flow field on a ship will often be affected by separated flow from various superstructures and deck equipment. The flow might also be affected by separated flow from other sails. There exist simplified models to account for this<sup class="footnote-reference" id="fr-model_note-2"><a href="#footnote-model_note">1</a></sup>. These models can be connected to the lifting line simulations by affecting the input freestream velocity. In that case, the position of each point in the simulation matter for how the velocity should be affected.</li>
<li><strong>CFD data as input:</strong> Using CFD data is a possible way to account for interactions with the rest of the ship. In that case, a velocity field from a simulation of the deck and superstructure can be used to generate an interpolation model, which later is used to specify a spatially varying velocity fields as input to the lifting line.</li>
</ul>
<h2 id="code-example"><a class="header" href="#code-example">Code example</a></h2>
<p>Generating the right velocity input consists of two steps. First, the user must query the simulation model for the relevant points. This happens by calling the <code>get_freestream_velocity_points</code> method. The <code>Simulation</code> structure/class will then return the right points, which as already mentioned, depends on the method used. These points can then be processed by the suer to generate a vector/list of spatial vectors for each of the relevant points, which are later given as input to the <code>do_step</code> method. A slightly simplified example is shown below. See the <a href="lifting_line/./../tutorials.html">code examples</a> for more.</p>
<pre><code class="language-python">from pystormbird.lifting_line import Simulation

# ----- code to set up the simulation first -----
simulation = Simulation(setup_string)

# Assumes this is a class in Python that models variation in wind speed as a function of height
wind_model = AtmosphericBoundaryLayer(
    ship_velocity           = ship_velocity,
    reference_wind_velocity = wind_velocity,
    wind_direction          = wind_direction
)

# Query the simulation model for the right points
freestream_velocity_points = simulation.get_freestream_velocity_points()

# Generate velocity vectors for each point
freestream_velocity = []
for point in freestream_velocity_points:
    local_velocity = wind_model.get_velocity(point) # List, such as [u_x, u_y, u_z]

    freestream_velocity.append(local_velocity)

# Run the simulation with the generated freestream velocity input
current_time = 0.0
time_step = 0.1

while current_time &lt; end_time:
    result = simulation.do_step(
        time = current_time,
        time_step = time_step,
        freestream_velocity = freestream_velocity
    )

    current_time += time_step
</code></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-model_note">
<p>There are actually implementations of atmospheric boundary layer (ABL) models and  viscous wake models on the Rust side of Stormbird. However, they are not yet exposed to the Python side. This will come soon. For now, custom Python implementations must be used. This is trivial for ABL models, but perhaps slightly more cumbersome for the viscous wake models. <a href="#fr-model_note-1">↩</a> <a href="#fr-model_note-2">↩2</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="actuator-line"><a class="header" href="#actuator-line">Actuator line</a></h1>
<p>An actuator line model shares a lot of the same principles as a lifting line model; the wings are divided into line segments, and the forces on each line segment are dependent on the local velocity and the output from the sectional models. However, unlike a lifting line simulation, there is no potential theory wake. The velocity at each control point is instead estimated directly from the velocity field in a CFD solver. The point of this is that other structures in the CFD domain will influence the felt velocity at each control point. For the sake of sail simulations, this allows for modeling the interaction effects between the deck and superstructure and the sails.</p>
<p>Lift-induced velocities due to the calculated forces on the sails are still included in the model. This happens through a force projection step, where the calculated forces on each line segment are projected back onto the CFD grid as body forces with a volumetric distribution. This creates a two-way coupling: the flow to the sails are affected by everything else in the CFD domain, and the flow over all other structures are affected by the forces from the sails.</p>
<figure>
    <img src="actuator_line/../static/actualtor_line_streamlines.png" alt="Actuator line streamlines">
    <figcaption>Figure 1: Examples of streamlines around wing sails on a ship that are simulated with the actuator line method. The interaction between the ship and the sails is in this case taken into account</figcaption>
</figure>
<h2 id="what-are-the-benefits"><a class="header" href="#what-are-the-benefits">What are the benefits?</a></h2>
<p>The main benefit with an actuator line model, over a full conventional CFD simulation, is computational speed. This comes, primarily, from the fact that it is possible to use much coarser mesh resolution around the wings itself. This comes from the fact that the boundary layer and geometry is not modeled directly. Rather, the forces on a section of the wing is simplified to mostly depend on the local velocity at each control point, which does not require a very fine mesh. An example of the difference in mesh resolution can be seen in Figure 2, which comes from <a href="https://www.researchgate.net/publication/374976524_Actuator_Line_for_Wind_Propulsion_Modelling">this paper</a>. As a rough guideline, an actuator line can represent the wings with an order of magnitude larger cells than a fully resolved wing.</p>
<figure>
    <img src="actuator_line/../static/al_mesh_resolution.png" alt="Actuator line mesh resolution">
    <figcaption>Figure 2: Examples of a convergence study done for both a fully resolved wing and for an actuator model of the same wing </figcaption>
</figure>
<h2 id="what-should-an-actuator-line-model-be-used-for"><a class="header" href="#what-should-an-actuator-line-model-be-used-for">What should an actuator line model be used for?</a></h2>
<p>Although fats compared to conventional CFD simulations, an actuator line simulation is still significantly slower than a lifting line simulation. In practical terms, what takes a few milliseconds with a lifting line model will take a few minutes when simulating wings alone. Also, the point of using an actuator line model is generally to include the rest of the ship in the simulation. This will also significantly increase the computational time required for each case, depending on the mesh resolution around the rest of the ship and, often as important, how complex the flow becomes around the ship and therefore how long the simulation needs to run.</p>
<p>Since the computational speed is measured in terms of minutes to a few hours, it is generally not a method that is fast enough for running directly in a route simulation. The recommended work flow for setting up a complete model of a wind propulsion device is therefore to use a combination of methods.</p>
<p>More specifically, an actuator line model can be used to measure the interaction between the sails and the rest of the ship for a few different operational conditions. This data can then later be used to make correction factor for a lifting line model. One approach for doing this is explained later, for the <a href="actuator_line/../utils/wind_model.html">effective wind model</a> functionality of the library. The correction factors tuned based on actuator line simulations can then later be interpolated on for wind conditions not directly tested. As such, <strong>the main point of the actuator line model is to provide a computationally effective way to measure interaction effects between sails and the rest of the ship, which later can be used to tune correction factors for faster lifting line models</strong>.</p>
<h2 id="why-not-just-measure-the-velocity-over-the-ship-without-any-sails-present"><a class="header" href="#why-not-just-measure-the-velocity-over-the-ship-without-any-sails-present">Why not just measure the velocity over the ship without any sails present?</a></h2>
<p>The effective velocity over a ship superstructure can also be measured in a CFD simulation with the ship alone, without any sails. In this case, the measured velocity at the locations where the sails should stand can be used as input to  a lifting line model directly.</p>
<p><strong>This type of simplified modeling is likely sufficient for many cases</strong>. However, one missing effect with this approach is the two-way coupling between the flow over the sails and the flow over the rest of the ship. The sails themselves might alter how the flow is separating and accelerated over the deck and past the superstructure. This effect should be captured better with an actuator line model due to the projection of the calculated forces back onto the CFD grid. Whether it is significant or not will likely depend on the specific ship, sail configuration, and sail type. However, an actuator line model is relatively cheap to add to a simulation that is anyhow simulating the rest of the ship. It is, therefore, not much added computational time to test the full two-way coupling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simulation-overview-1"><a class="header" href="#simulation-overview-1">Simulation overview</a></h1>
<p>The actuator line model is mostly managed through the <code>ActuatorLine</code> structure, which is a pure Rust implementation of <strong>most</strong> of the functionality needed for this medellin type. However, this model cannot execute a complete simulation alone; it needs to be <strong>combined with a CFD solver</strong>, and some of the functionality for the model is also necessary to implement directly in the direct interface to the CFD solver, rather than in the Stormbird library itself. In particular, this is the case for of the <a href="actuator_line/velocity_sampling.html">velocity sampling</a> functionality. See also the <a href="actuator_line/cfd_interface.html">CFD interface chapter</a> for more details on how the coupling works in practice for the case of OpenFOAM.</p>
<p>That being said, as much functionality as possible is still kept on the Stormbird side, to make it easier to use the same library across different CFD solvers.</p>
<h2 id="creating-a-simulation-1"><a class="header" href="#creating-a-simulation-1">Creating a simulation</a></h2>
<p>The builder pattern is used to create an actuator line simulation. The main structure for this is the <code>ActuatorLineBuilder</code>, where the available fields is shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ActuatorLineBuilder {
    pub line_force_model: LineForceModelBuilder,
    pub projection_settings: ProjectionSettings,
    pub solver_settings: SolverSettings,
    pub sampling_settings: SamplingSettings,
    pub controller: Option&lt;ControllerBuilder&gt;,
    pub write_iterations_full_result: usize,
    pub start_iteration: usize,
    pub lifting_line_correction: Option&lt;LiftingLineCorrectionBuilder&gt;,
    pub empirical_circulation_correction: Option&lt;EmpiricalCirculationCorrection&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>In the same way as for the rest of the library, this structure can be automatically deserialized from a JSON input file. As such, to create a setup to be used within a CFD solver, it is mostly a matter of creating the right JSON string. This can be done directly, or through the <a href="https://github.com/NTNU-IMT/stormbird/tree/main/interfaces/stormbird_setup">stormbird_setup</a> Python library.</p>
<p>All settings have default values, so the only required field to get started is the <code>line_force_model</code>. This field specifies the sail geometry, using the exact same format as for lifting line simulations. See the <a href="actuator_line/../line_model/line_model_intro.html">line model chapter</a> for more details on how to create a builder for the line force model.</p>
<p>The other settings mainly control how the velocity is sampled from the CFD domain, how the forces are projected back, and what type of corrections to use. There are some details for all of these which can be important to know about. As a <strong>general warning</strong>, actuator line models can be said to be affected more by details in the settings than, for instance, a lifting line simulation. As such, some care should be taken when setting up the model to ensure that the settings are appropriate for the specific case. More on this in the respective chapters for <a href="actuator_line/velocity_sampling.html">velocity sampling</a>, <a href="actuator_line/force_projection.html">force projection</a> and <a href="actuator_line/corrections.html">corrections</a>.</p>
<h2 id="running-a-simulation-1"><a class="header" href="#running-a-simulation-1">Running a simulation</a></h2>
<p>The overall execution of an actuator line simulation is, necessarily, controller from the CFD solver. That is, the duration of the simulation, the time step, what type of disturbances to include, and the general freestream velocity must all be part of the CFD setup. For each time step, the following happens internally in code:</p>
<ol>
<li>The <strong>velocity on the control point of each line segment</strong> in the line force model is sampled from the CFD domain, using one of the available <a href="actuator_line/velocity_sampling.html">velocity sampling methods</a>.</li>
<li><strong>The circulation strength on each line segment is calculated</strong> based on the sampled velocity and the sectional models, in the same way as for the <a href="actuator_line/../lifting_line/solver.html">non-linear solver</a> in the lifting line model, but with only one iteration. That is, the new circulation is estimated directly from the velocity, but the final values can be based on the previous time step as well, using the same general damping technique as for the lifting line model. The reason for using only one iteration is that no way to update the velocity fields in the CFD domain outside the general solver loop. As such, the number of iterations are inherently controlled by the CFD solver directly, and not by the actuator line model.</li>
<li><strong>If any corrections are enabled</strong>, these are applied to the estimated circulation strength. The corrections may be crucial for accurate results. See the <a href="actuator_line/corrections.html">corrections chapter</a> for more details on what corrections are available and when they should be used.</li>
<li>Based on the estimated circulation strength, the forces on each line segment are calculated, and the <strong>circulatory forces are projected back to the CFD grid</strong> using the methods and settings specified in the <a href="actuator_line/force_projection.html">force projection chapter</a> chapter.</li>
<li>The <strong><a href="actuator_line/../line_model/force_calculations.html">result data</a></strong> for each time step will finally be written to disk, and the actuator line model is ready for the next time step.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="velocity-sampling"><a class="header" href="#velocity-sampling">Velocity sampling</a></h1>
<p>As with the lifting line method, the actuator line method needs the velocity at each control point in the line force model to compute the forces acting on each line segment. There are in general two different methods to obtain these, described in the subsections below. The overall structure controlling the sampling method is also shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SamplingSettings {
    pub use_point_sampling: bool,
    pub span_projection_factor: Float,
    pub neglect_span_projection: bool,
    pub weight_limit: Float,
    pub extrapolate_end_velocities: bool,
    pub remove_span_velocity: bool,
    pub correction_factor: Float
}
<span class="boring">}</span></code></pre></pre>
<p>Some of the settings are independent of the sampling methods chosen. In particular, this is true for the following settings:</p>
<ul>
<li><code>extrapolate_end_velocities</code>: If true, the velocities at the end control points are extrapolated from the inner control points to avoid edge effects. It is set to false by default.</li>
<li><code>remove_span_velocity</code>: If true, the component of the velocity along the actuator line segment is removed from the sampled velocity. It is set to false by default.</li>
<li><code>correction_factor</code>: A global correction factor applied to all sampled velocities, which can be used to either artificially increase or decrease the velocity magnitude. It is set to 1.0 by default, which means that it does not change the sampled velocities at all.</li>
</ul>
<h2 id="direct-interpolation"><a class="header" href="#direct-interpolation">Direct interpolation</a></h2>
<p>The first and most direct method is to simply use interpolated velocities from the CFD grid at each control point. This method relies on the built in interpolation methods in the CFD solver, which means that the order of the interpolation is also chosen by the CFD solver. For a second order unstructured CFD code, like OpenFOAM, the interpolation will often be linear. To active this method, simply set the <code>use_point_sampling</code> flag to true in the <code>SamplingSettings</code>.</p>
<h2 id="body-force-weighted-estimate"><a class="header" href="#body-force-weighted-estimate">Body force weighted estimate</a></h2>
<p>The second method for velocity sampling is implemented based on the explanation in the paper by <a href="actuator_line/../literature/simulation_methods.html#an-advanced-actuator-line-method-for-wind-energy-applications-and-beyond-2017">Churchfield et al., 2017</a>. Rather than using a direct interpolation, the velocity at each control point is estimated using a Gaussian weighted average of the velocities in the CFD cells around each control point. The weighting is set to be identical to the kernel used to <a href="actuator_line/force_projection.html">project the force</a> back into the CFD domain, along the two dimensions normal to the span line.</p>
<p>The additional settings variables for this sampling method are generally connected to how the Gaussian kernel should be along the spanwise direction for each line segment. There are two variables controlling this:</p>
<ul>
<li><code>span_projection_factor</code>: This variable sets the width of the Gaussian kernel along the spanwise direction as a multiple of the local line segment length. The default value is 0.5. That is, it is the cells closest to the control point that will influence the sampled velocity the most, also in the spanwise direction. The fall off in the spanwise direction is controller by this factor.</li>
<li><code>neglect_span_projection</code>: If this flag is set to true, the Gaussian kernel is assumed to be infinitely wide along the spanwise direction, effectively reducing the kernel to a 2D Gaussian in the plane normal to the line segment. However, only cells that are normal to the span line is included in the weighted average; cells that are either <em>above</em> or <em>below</em> is neglected. The weight of each cell is still based on the 2D force projection kernel, just no longer any spanwise distribution. The default value is false.</li>
</ul>
<p>This method is claimed to be more robust against numerical noise, in particular when using coarse grids. It also has the benefit that the interpolation method itself is not dependent on the CFD solver so that it is easy to use with any solver.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="force-projection"><a class="header" href="#force-projection">Force projection</a></h1>
<p>The forces calculated on each line segment need to be projected back onto the CFD grid as body force to deflect the flow in as similar way as possible to a real wing. In other words, the force projection step is a requirement for actually introducing lift-induced velocities in the simulation. Without it, the force on each sail will not be affected by neither itself or other sails in the simulation. The force projection step is therefore a crucial part of the actuator line method.</p>
<p>There are a few different ways to project these forces, and the choice of method can have a significant effect on the final results.</p>
<h2 id="basic-principle"><a class="header" href="#basic-principle">Basic principle</a></h2>
<p>For each line segment in the line force model, there are force vectors representing different <a href="actuator_line/../line_model/force_calculations.html">force types</a>. When running an actuator line simulation, it is only the <strong>circulatory force</strong> that is projected by default. The other force types are still modeled, but not projected back to the CFD grid.</p>
<p>The force on each line segment is assumed to act at the control points, or the middle of each line segment. However, it is not possible to simply add a single force vector for each point back to the CFD domain. If, lets say, each force where added to the cell closest to each control point, the resulting force field would be very extreme, and cause instabilities in the flow domain. As such, the force on each line segment needs to be distributed over a volume around each control point.</p>
<p>The goal with the force projection logic, then, is to find a way to distribute the calculated forces on each line segment in a way that is both <strong>smooth</strong> AND than creates a <strong>flow deflection that is as close as possible to the one created by a real wing</strong>.</p>
<h2 id="background-for-the-choice-of-force-projection-method"><a class="header" href="#background-for-the-choice-of-force-projection-method">Background for the choice of force projection method</a></h2>
<p>The method implemented in Stormbird is based on a combination of techniques from the literature. It can be summarized as a two-dimensional Gaussian kernel in the plane normal to each line segment, but with anisotropic widths in the chord direction and the direction normal to both the chord and span directions. The last direction is also referred to as the "thickness direction".</p>
<p>Below is a short summary of how three different papers have influenced the final choice of method.</p>
<h3 id="original-method"><a class="header" href="#original-method">Original method</a></h3>
<p>The original, and still most common, method for force projection, as for instance explain in the paper by <a href="actuator_line/../literature/simulation_methods.html#numerical-modeling-of-wind-turbine-wakes-2002">Sørensen et. al (2002)</a>, uses a uniform Gaussian kernel. That is, the width of the kernel is identical in all directions. This creates a volumetric distribution that is smooth everywhere and easy to implement. As such, it is still a common choice in many papers describing actuator line methods.</p>
<p>However, this method was thought to have a few practical issues. The biggest one is that it may result in forces being projected significantly far outside the tip and root regions of the wing, as the width of the Gaussian kernel is, necessarily, not directly dependent on the length of the line segment. This creates situations where the width of the Gaussian kernel should really be tuned very carefully to the number of line segments in the model, or one risks having an effective span length that is larger than the real wing. In addition, it might create non-physical circulation distribution if the Gaussian kernel width is set too small, compared to length of the line segment.</p>
<h3 id="introduction-of-the-two-dimensional-kernel"><a class="header" href="#introduction-of-the-two-dimensional-kernel">Introduction of the two-dimensional kernel</a></h3>
<p>An simple solution to the issues described above was introduced in the PhD-thesis by <a href="actuator_line/../literature/simulation_methods.html#actuator-disc-methods-applied-to-wind-turbines-2004">Mikkelsen, 2004</a>. Rather than using the simple uniform kernel, he suggested a 2D kernel, where the force is smoothed only in the directions normal to the line segment, while being kept constant in strength along the spanwise direction of each line segment. Outside the line segment, the volume force is set to zero. This allows the force projection width to be set independently of the length of each line segment. The resulting force distribution is, also, more similar to how it would be in a discrete lifting line method with constant strength vortex elements.</p>
<p><strong>Stormbird therefore uses a two-dimensional Gaussian kernel for the force projection</strong>, rather than the conventional 3D kernel.</p>
<h3 id="anisotropic-kernel"><a class="header" href="#anisotropic-kernel">Anisotropic kernel</a></h3>
<p>A final improvement available in the Stormbird library, relative to the original method, was inspired by the suggested force distribution in the paper by <a href="actuator_line/../literature/simulation_methods.html#an-advanced-actuator-line-method-for-wind-energy-applications-and-beyond-2017">Churchfield et al., 2017</a>. They tested an anisotropic Gaussian distribution, where the width of the kernel could be set independently in the chordwise, thickness, and spanwise directions. The idea was that most wings have a thickness that is significantly smaller than the chord length. By distributing the force more narrowly in the thickness direction, the resulting flow deflection could, perhaps, be more similar to a real wing. They show results that indicate that an anisotropic kernel can provide better results in terms of measured lift and drag forces than an isotropic one.</p>
<p><strong>Stormbird therefore allows for setting different widths in the chord and thickness directions</strong>. The distribution in the spanwise direction still follows the same logic as for the unfiform two-dimensional kernel suggested by <a href="actuator_line/../literature/simulation_methods.html#actuator-disc-methods-applied-to-wind-turbines-2004">Mikkelsen, 2004</a>.</p>
<h2 id="input-structures"><a class="header" href="#input-structures">Input structures</a></h2>
<p>The force distribution in Stormbird is controlled through the <code>ProjectionSettings</code> and <code>Gaussian</code> structures, shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Gaussian {
    pub chord_factor: f64,
    pub thickness_factor: f64,
}

pub struct ProjectionSettings {
    pub projection_function: Gaussian,
    pub project_normal_to_velocity: bool,
    pub weight_limit: f64,
    pub project_sectional_drag: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Gaussian</code> structure controls the width of the Gaussian kernel in the chord and thickness directions. The width in each direction is set as a multiple of the local chord length. For instance, if the <code>chord_factor</code> is set to 0.25, the width of the Gaussian kernel in the chord direction will be equal to a quarter of the chord length.</p>
<p>The <code>ProjectionSettings</code> structure contains some additional settings for the force projection step. The most important ones are described below:</p>
<ul>
<li><code>project_normal_to_velocity</code>: If true, the force vector on each line segment is projected onto the plane normal to the local velocity vector before being distributed to the CFD grid. This is mostly a feature implemented for testing purposes. It is set to false as default, which is also the recommended setting.</li>
<li><code>weight_limit</code>: This variable sets a lower limit for the weight of each CFD cell in the force projection step. Cells with a weight lower than this limit will not receive any force contribution from the line segment. This is mainly used in the CFD interface to determine which cells that needs to be looped over or not during the force projection step. The default value is 0.001.</li>
<li><code>project_sectional_drag</code>: If true, the sectional drag force on each line segment is also projected back to the CFD grid, in addition to the circulatory force. It is set to false as default, which is also the recommended setting.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="corrections"><a class="header" href="#corrections">Corrections</a></h1>
<p>The accuracy of an actuator line model is sensitive to both the force projection (shape and width), the mesh resolution in the CFD simulation, and the velocity sampling method. First, just to clarify, it is generally thought that wings will be simulated with a similar accuracy as a lifting line model IF the projection width is set to be sufficiently small, AND the mesh resolution is sufficiently high to allow for a small projection width. That is, an <strong>actuator line model should converge towards a lifting line model</strong> when the projection width is reduced.</p>
<p>However, at least when using isotropic force projections, it is often impractical to have a small enough force projection width to allow for this. This is especially the case as the whole point of using an actuator line model, rather than a direct CFD simulation, is to significantly reduce the number of cells used in a simulation. As such, it is fairly <strong>common to combine an actuator line model with some form of correction</strong> to the <em>raw circulation distribution</em>, to achieve better accuracy at coarse meshes. In particular, the main issue with an actuator line model is typically that the <strong>tip circulation is predicted to be too large</strong>. Or, in other words, the lift-induced velocities on the tip is too small.</p>
<p>As explored in the paper by <a href="actuator_line/../literature/simulation_methods.html#an-advanced-actuator-line-method-for-wind-energy-applications-and-beyond-2017">Churchfield et al., 2017</a>, this is an issue that might be also be solved by using force projection shapes that are more physically representative of a real wing, i.e. like with anisotropic kernels. However, other techniques are also often used, and the exact effect of the anisotropic force projection width deserves more investigation.</p>
<p>The Stormbird  library currently implements two different correction methods based on suggestions from the literature.</p>
<h2 id="lifting-line-correction-for-the-induced-velocity"><a class="header" href="#lifting-line-correction-for-the-induced-velocity">Lifting line correction for the induced velocity</a></h2>
<h3 id="background"><a class="header" href="#background">Background</a></h3>
<p>The first, and perhaps most promising, correction technique comes from the paper by <a href="actuator_line/../literature/simulation_methods.html#a-new-tip-correction-for-actuator-line-computations-2020">Dag and Sørensen, 2020</a>. The idea is based on an important observation: the lift-induced velocities from an actuator line model with a certain projection width, and an isotropic force projection kernel, seem to almost perfectly match the lift-induced velocity from a lifting line model with the same circulation distribution and a <strong>viscous core length equal to the projection width</strong>. That is, the vortices created by an actuator line model is like a smoothed, viscous, version of a pure potential theory vortex. The solution from this observation, suggested by Dag and Sørensen, is then to compute the error in the velocity field explicitly using a simple lifting line model, that directly quantify the effect of the viscous core.</p>
<p>For each time step in the simulation, the circulation strength from the previous time step is known. These strength values are also the values used when projecting the forces at the previous time step, and the strength that was active when the velocity from the CFD domain was sampled. A correction to the sampled velocity can then be computed based on the difference in the induced velocity from a lifting line model with and without a viscous core.</p>
<p>This is done by first computing the lift-induced velocities from a lifting line wake model with a viscous core equal to the projection width, and then doing the same calculation with very small core length. The difference in the induced velocity between the two wake models at each control point can then be used to correct the sampled velocity from the CFD grid.</p>
<h3 id="wake-shape"><a class="header" href="#wake-shape">Wake shape</a></h3>
<p>One challenge with such an approach is that the shape of the wake must be assumed somehow. This is a trivial task if there is only a single wing, but more difficult if there are multiple wings in close proximity OR wings standing on a ship superstructure. However, the point of the lifting line corrections is <strong>only to compute the error due to a too large projection width</strong>. The effect of a viscous core on the induced velocities are most significant from the wake close to the wing. The effect from the vortices far downstream should be small. The exact wake shape for the correction may, therefore, not be that important.</p>
<p>As a simple solution to this, the lifting line correction in Stormbird assumes a steady wake shape, with a direction equal to the average sampled velocity over each wing. The correction for each wing is also simulated independently. That is, <strong>the correction should NOT affect interaction effects between wings in any way</strong>, only errors due to a too large viscous core on the wings own wake. This is choice is made to keep the correction method local to a single wing. In other words, the lifting line correction only correct for errors in the <em>self-induced</em> velocities, and not interaction effects.</p>
<p>The actual code used to calculate the correction for a given time step is the same as the steady <a href="actuator_line/../lifting_line/wake.html">wake models</a> used in the lifting line methods.</p>
<h3 id="input-structure"><a class="header" href="#input-structure">Input structure</a></h3>
<p>To activate the lifting line correction, set the a value for <code>lifting_line_correction</code> in the <code>ActuatorLineBuilder</code>. The available options are shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LiftingLineCorrectionBuilder {
    pub wake_length_factor: f64,
    pub symmetry_condition: SymmetryCondition
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>wake_length_factor</code> is set to 100.0 by default, which means that the wake used for computing lift-induced velocities is assumed to extend 100 chord lengths downstream. The <code>symmetry_condition</code> is set to <code>NoSymmetry</code> by default. The symmetry condition should generally reflect the same symmetry condition as used in the CFD simulation. For instance, if the bottom of the domain is at the lowest z-coordinate, the symmetry condition should be set to <code>Z</code>.</p>
<p>Experience from this correction technique is that it works very well for actuator line simulations that only includes wings. Even with a <strong>large isotropic projection width</strong>, the result from an actuator line simulation will match the lifting line model almost perfectly. However, it can also create instabilities when combined with complex ship geometries. <strong>The hope is to find a solution to this in the future</strong>, as this type of correction is believed to be very general and promising for practical use cases.</p>
<h2 id="empirical-circulation-correction"><a class="header" href="#empirical-circulation-correction">Empirical circulation correction</a></h2>
<p>A more classical correction technique for actuator line simulations is to use an empirical correction factor to the calculated circulation on each wing. As mentioned, the <em>raw circulation at the tips</em> is often predicted to be too large. A simple solution is, then, to artificially reduce it based on a analytical correction. There are many small variations in how this is done. A recent discussion about the topic can be found in the paper by <a href="actuator_line/../literature/simulation_methods.html#spanwise-flow-corrections-for-tidal-turbines-2018">Wimshurst and Willden, 2018</a>. The correction in Stormbird follows the following principle:</p>
<p>The raw circulation distribution, \( \Gamma_{raw} \), estimated directly from the sampled velocity, is multiplied by a correction function, \( f_{cor}(s) \), that takes the non-dimensional span distance at each wing, \( s \) as input, as well as a shape parameter \( \beta \). The function has the following shape:</p>
<p>\[
f_{cor}(s) = \frac{2.0}{\pi}\cos^{-1}(e^{-\beta (0.5 - |s|)})
\]</p>
<p>The plot below shows how the correction function looks for different values of \( \beta \). In general, any value of \( \beta \) will force the circulation towards zero at the tips. However, the larger the value, the steeper the reduction towards the tip, and the less effect it has on the inner part of the wing.</p>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<div id="circulation-correction-plot"></div>
<script src="plot_scripts/circulation-correction-plot.js"></script>
<h3 id="input-structure-1"><a class="header" href="#input-structure-1">Input structure</a></h3>
<p>To active this correction, the <code>EmpiricalCirculationCorrection</code> structure must be set in the <code>ActuatorLineBuilder</code>, as shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EmpiricalCirculationCorrection {
    pub exp_factor: f64,
    pub overall_correction: f64,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>exp_factor</code> corresponds to the \( \beta \) variable in the equation above. It is set to 10.0 by default, but should ideally always be tuned for the specific case. The idea with this type of correction is to first tune the shape parameter based on simulation of a single wing, and then assume that it can remain constant also when simulating multiple wings or wings on a ship.</p>
<p>The <code>overall_correction</code> is a global correction factor applied to the entire circulation distribution, that can be used to either increase or decrease the overall circulation level. It is set to 1.0 by default.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openfoam-interface"><a class="header" href="#openfoam-interface">OpenFOAM interface</a></h1>
<p>The actuator line functionality in the core Stormbird library is written in a general way, and could be coupled to any CFD solver. However, at the moment, the only interface made is towards the open-source CFD solver <a href="https://openfoam.com/">OpenFOAM</a>. This chapter describes how the coupling works in practice, and what is necessary to set up a simulation using OpenFOAM together with Stormbird.</p>
<h2 id="cfd-interfaces"><a class="header" href="#cfd-interfaces">CFD interfaces</a></h2>
<p>The general source code for interfaces towards CFD solver is located in the <a href="https://github.com/NTNU-IMT/stormbird/tree/main/interfaces/cfd_interfaces">cfd_interfaces folder</a> on Github. OpenFOAM is a c++ library, which is also a common language for other CFD codes. In an attempt to generalize as much as possible, the interface between Stormbird and OpenFOAM is divided in two parts.</p>
<p>The first part is a general C++ interface to the actuator line functionality in Stormbird. This source code is found in the <a href="https://github.com/NTNU-IMT/stormbird/tree/main/interfaces/cfd_interfaces/cpp_actuator_line">cpp_actuator_line</a> folder on Github. It contains functionality to set up and call the Rust code from C++. The interface is made using the <a href="https://cxx.rs/">cxx crate</a>. It function names and data structures follows the Rust side as much as possible.</p>
<p>The second part is specific to OpenFOAM. This source code is found the <a href="https://github.com/NTNU-IMT/stormbird/tree/main/interfaces/cfd_interfaces/openfoam">openfoam</a> folder on Github. It implements a class called <code>ActuatorLine</code> that inherits from the standard <code>cellSetOption</code> class in OpenFOAM. The <code>cellSetOption</code> base class is used to implement volume forces that are added to the momentum equations for a variety of functionalities in the OpenFOAM library. The connection logic behind this class and the other OpenFOAM solvers therefore follows the same principle as any other <code>fvOption</code> source in OpenFOAM.</p>
<p>The responsibility of the OpenFOAM interface is mainly to extract information from the CFD domain, such as the velocity field, pass it to the Stormbird library, and the project the resulting forces back to the CFD grid.</p>
<h2 id="installing-the-openfoam-interface"><a class="header" href="#installing-the-openfoam-interface">Installing the OpenFOAM interface</a></h2>
<p>Instructions for how to install the OpenFOAM interface can be found in the <a href="https://github.com/NTNU-IMT/stormbird/tree/main/interfaces/cfd_interfaces/openfoam">README file</a> at the OpenFOAM interface Github page.</p>
<h2 id="setting-up-an-openfoam-simulation"><a class="header" href="#setting-up-an-openfoam-simulation">Setting up an OpenFOAM simulation</a></h2>
<p>Examples of how to use the OpenFOAM interface can be found in the <a href="https://github.com/NTNU-IMT/stormbird/tree/main/interfaces/cfd_interfaces/openfoam/examples">examples folder</a> on GitHub.</p>
<p>As with any other <code>fvOption</code> model in OpenFOAM, the actuator line model is activated by specifying it in the <code>fvOptions</code> file in the <code>system</code> folder. However, unlike native OpenFOAM models, the general setup is not defined directly in the <code>fvOption</code> file. Rather, the only thing that is necessary to specify in the <code>fvOptions</code> file is the following <sup class="footnote-reference" id="fr-interface_note-1"><a href="#footnote-interface_note">1</a></sup>:</p>
<pre><code class="language-c++">FoamFile
{
    version    2.0;
    format    ascii;
    class     dictionary;
    object    fvOptions;
}

actuatorLine
{
    type actuatorLine;
    selectionMode   all;
    fields (U);
    name actuatorLine;
}
</code></pre>
<p>This activates the actuator line functionality. The <code>ActuatorLine</code> class will then look for a JSON input file in the <code>system</code> folder called <code>stormbird_actuator_line.json</code>. The content of this file is a JSON representation of the <code>ActuatorLineBuilder</code> structure. If the file does not exists, or contains invalid settings, the OpenFOAM simulation will crash. The error message from OpenFOAM is messy in general, but there should be instructions from the Rust side within the crash log, typically on the top, explaining what went wrong.</p>
<h2 id="results"><a class="header" href="#results">Results</a></h2>
<p>Results from the simulation will be placed in the <code>postProcessing</code> folder in the case directory, like other post-processing data in OpenFOAM. There will be two types of result files:</p>
<ul>
<li><strong>The first is a simple csv file with forces</strong> as a function of time. This file will be called <code>stormbird_forces.csv</code>. The forces are written for every time step. The point of this file is to have a simple representation of the most important values from a simulation</li>
<li><strong>The second is folder with full simulation result data</strong>. How often this data is written is controlled by the <code>write_iterations_full_result</code> parameter in the <a href="actuator_line/simulation_overview.html">ActuatorLineBuilder</a> structure. If this value is set 100, the full results will be written every 100 time step. The folder is called <code>stormbird_full_results</code> and will contain several JSON files with <a href="actuator_line/../line_model/force_calculations.html">SimulationResult</a> data. This data is useful for looking more detailed into the results, such as the circulation distribution and the angles of attack on each line segment.</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-interface_note">
<p>The interface for the setup kept simple, but might also probably a bit too basic to cover all situations at the moment. It might therefore be extended with more options in the future, depending on what is needed. <a href="#fr-interface_note-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="other-functionalities"><a class="header" href="#other-functionalities">Other functionalities</a></h1>
<p>The library also contains several helper functionalities that model things that are useful for wind propulsion simulations, but that, technically speaking, is not parts of either the lifting line or actuator line methods. These functionalities are described in this chapter.</p>
<p>This chapters is, however, still under construction. The plan is to extend the sub-chapters with <strong>more details "soon"</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wind-environment"><a class="header" href="#wind-environment">Wind environment</a></h1>
<p>DESCRIPTION TO BE EXTENDED LATER. AlSO, THE EXACT SHAPE OF THE DATA STRUCTURE STILL UNDER DEVELOPMENT.</p>
<p>The Stormbird library contains a data structure for representing the wind environment in different situations. The main point of this structure is to be able to provide spatially varying inflow conditions at all relevant points in a simulation. This fits most naturally with the lifting line simulations, but the wind model is kept separate so that it can, potentially, also be used with other simplified models of wind propulsion devices if needed.</p>
<p>The basic structure for the wind environment is given below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WindEnvironment {
    pub height_variation_model: Option&lt;HeightVariationModel&gt;,
    pub up_direction: SpatialVector,
    pub wind_rotation_axis: SpatialVector,
    pub zero_direction_vector: SpatialVector,
    pub water_plane_height: f64,
    pub inflow_corrections: Option&lt;InflowCorrections&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The fields in the structure are described below:</p>
<ul>
<li><code>height_variation_model</code>: An optional model for how the wind speed varies with height above the water surface. If this is not specified, the wind speed is assumed to be constant with height.</li>
<li><code>up_direction</code>: A vector defining the "up" direction in the simulation. This is used to determine the height above the water surface.</li>
<li><code>wind_rotation_axis</code>: A vector defining the axis where the wind direction is rotated around when changing wind direction.</li>
<li><code>zero_direction_vector</code>: A vector defining the reference direction for the wind. The wind will point along this vector when the wind direction angle is zero.</li>
<li><code>water_plane_height</code>: A scalar defining the height of the water plane in the simulation.</li>
<li><code>inflow_corrections</code>: An optional structure containing corrections to be applied to the inflow velocity, which is primarily intended for modeling disturbances due to the rest of the ship. See more about this correction model below.</li>
</ul>
<h2 id="height-variation-models"><a class="header" href="#height-variation-models">Height variation models</a></h2>
<p>The height variation models can be set with the following Enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum HeightVariationModel {
    PowerModel(PowerModel),
    LogarithmicModel(LogarithmicModel),
}
<span class="boring">}</span></code></pre></pre>
<p>That is, one can choose between a power law model and a logarithmic model for the wind speed variation with height. The input structures for the two models are shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PowerModel {
    pub reference_height: f64,
    pub power_factor: f64,
}

pub struct LogarithmicModel {
    pub reference_height: f64,
    pub surface_roughness: f64,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="inflow-corrections"><a class="header" href="#inflow-corrections">Inflow corrections</a></h2>
<p>NOTE: These structures, in particular, have room for improvements. Might therefore change in future versions. MORE TO COME LATER.</p>
<p>The <code>inflow_corrections</code> variable is a data structure used to store corrections to the freestream velocity due to anything that might disturb the inflow. That is, it is primarily intended to model the wind disturbances caused by the ship itself. The data structure is set up such that the correction can depend on both the spanwise position along each sail and the apparent wind direction.</p>
<p>The correction factors themselves consist of two parts: A magnitude factor that scales the local inflow velocity, and an angle correction that modifies the local apparent wind angle.</p>
<p>The data structures to set this up is shown below. In practice, these structures are just used to do linear interpolation on the correction factors as needed during the simulation.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InflowCorrectionSingleSailSingleDirection {
    pub non_dimensional_span_distances: Vec&lt;f64&gt;,
    pub wake_factors_magnitude: Vec&lt;f64&gt;,
    pub angle_corrections: Vec&lt;f64&gt;,
}

pub struct InflowCorrectionSingleSail {
    pub apparent_wind_directions: Vec&lt;f64&gt;,
    pub corrections: Vec&lt;InflowCorrectionSingleSailSingleDirection&gt;,
}

pub struct InflowCorrections {
    pub individual_corrections: Vec&lt;InflowCorrectionSingleSail&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tuning-the-inflow-corrections"><a class="header" href="#tuning-the-inflow-corrections">Tuning the inflow corrections</a></h3>
<p>TO COME</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-system"><a class="header" href="#control-system">Control system</a></h1>
<p>NOTE: the control system functionality is planned to be changed in version 0.8.0. Right now, the same control logic must be applied for all sails in the simulation, which is an necessary limitation. This will therefore be changed soon! More detailed documentation for the control system logic will therefore come later.</p>
<p>The library contain different control system that can be used to automatically adjust the sail settings for different wind conditions. The goal is to have a system that covers most uses cases. The controller can automatically be activated for different versions of the Stormbird library. However, it is also usually possible to run custom control systems in various ways with the different APIs.</p>
<p>The structures used to set up a control system is shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ControllerBuilder {
    pub logic: ControllerLogic,
    pub flow_measurement_settings: FlowMeasurementSettings,
    pub time_steps_between_updates: usize,
    pub start_time: Float,
    pub max_local_wing_angle_change_rate: Option&lt;f64&gt;,
    pub max_internal_section_state_change_rate: Option&lt;f64&gt;,
    pub moving_average_window_size: Option&lt;usize&gt;,
    pub use_input_velocity_for_apparent_wind_direction: bool,
}

pub struct ControllerLogic {
    pub apparent_wind_directions_data: Vec&lt;f64&gt;,
    pub angle_of_attack_set_points_data: Option&lt;Vec&lt;f64&gt;&gt;,
    pub section_model_internal_state_set_points_data: Option&lt;Vec&lt;f64&gt;&gt;,
    pub internal_state_type: InternalStateType,
    pub use_effective_angle_of_attack: bool,
}

pub enum InternalStateType {
    Generic,
    SpinRatio(SpinRatioConversion),
}

pub struct SpinRatioConversion {
    diameter: f64,
    max_rps: f64,
}

pub struct FlowMeasurementSettings {
    pub angle_of_attack: MeasurementSettings,
    pub wind_direction: MeasurementSettings,
    pub wind_velocity: MeasurementSettings,
}

pub struct MeasurementSettings {
    pub measurement_type: MeasurementType,
    pub start_index: usize,
    pub end_offset: usize,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="empirical-models"><a class="header" href="#empirical-models">Empirical models</a></h1>
<p>Pure empirical models that may be used on combination with other models in the library.</p>
<h2 id="parametric-model-for-wind-loads-on-a-ship-superstructure"><a class="header" href="#parametric-model-for-wind-loads-on-a-ship-superstructure">Parametric model for wind loads on a ship superstructure</a></h2>
<p>An empirical model for the forces acting on a superstructure. Included in the library to be able to make a "complete" model of the aerodynamics on a ship. The current method is very basic and consists of a slightly simplified version the <a href="https://doi.org/10.1016/0167-6105(94)90067-1">Blendermann model</a>.</p>
<p>MORE TO COME</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BlendermannSuperstructureForces {
    pub frontal_area: f64,
    pub side_area: f64,
    pub center_of_effort: SpatialVector,
    pub resistance_coefficient: f64,
    pub side_force_coefficient: f64,
    pub coupling_factor: f64,
    pub density: f64,
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literature"><a class="header" href="#literature">Literature</a></h1>
<p>This chapter gives references to relevant literature that can serve as useful additional reading when working with the Stormbird models.</p>
<p>The chapter is divided into two sub-chapters:</p>
<ol>
<li><a href="literature/similar_simulation_methods.html">Simulation methods</a> contains references to papers that cover similar or identical methods as the ones implemented in Stormbird. That is, papers covering lifting line and actuator line methods.</li>
<li><a href="literature/validation_data.html">Validation data</a> contains references to papers that provide data that can be used to validate the output from Stormbird simulations. That is, generally experimental data or high-fidelity CFD simulations of wind propulsion devices.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simulation-methods"><a class="header" href="#simulation-methods">Simulation methods</a></h1>
<p>This chapter gives references to papers and other literature that use similar or identical methods as the ones implemented in Stormbird. These can be read to gain better understanding of the underlying methods, or to find alternative implementations to the Stormbird library.</p>
<h2 id="publications-using-stormbird"><a class="header" href="#publications-using-stormbird">Publications using Stormbird</a></h2>
<p>Articles that use the Stormbird library directly is shown in the sub sections below.</p>
<h4 id="sail-induced-resistance-on-a-wind-powered-cargo-ship-2022"><a class="header" href="#sail-induced-resistance-on-a-wind-powered-cargo-ship-2022">Sail-induced resistance on a wind-powered cargo ship, 2022</a></h4>
<p>By J. V. Kramer and S. Steen. A larger article that was really about the hydrodynamic modeling of wind-powered ships. However, an early version of the lifting line method implemented in Stormbird was used for the sail modeling. It also contains a simple validation experiment that compares lifting line simulations against CFD. Can be downloaded <a href="https://doi.org/10.1016/j.oceaneng.2022.111688">here</a>.</p>
<h4 id="actuator-line-for-wind-propulsion-modelling-2023"><a class="header" href="#actuator-line-for-wind-propulsion-modelling-2023">Actuator line for wind propulsion modelling, 2023</a></h4>
<p>By J. V. Kramer and S. Steen. Compares CFD, lifting line and actuator line simulations against each other for a case that includes two wing sails in close proximity. The actuator line simulations also contains the effect of a superstructure.Can be downloaded <a href="https://www.researchgate.net/publication/374976524_Actuator_Line_for_Wind_Propulsion_Modelling">here</a>.</p>
<h4 id="optimizing-wing-sails-with-actuator-line-simulations-and-an-effective-angle-of-attack-controller-2025"><a class="header" href="#optimizing-wing-sails-with-actuator-line-simulations-and-an-effective-angle-of-attack-controller-2025">Optimizing Wing Sails with Actuator Line Simulations and an Effective Angle of Attack Controller, 2025</a></h4>
<p>By J. V. Kramer. Further testing of the actuator line model, as well as a first test of a simple controller for the angle of attack for a wing sail. Can be downloaded <a href="https://www.researchgate.net/publication/396775692_Optimizing_Wing_Sails_with_Actuator_Line_Simulations_and_an_Effective_Angle_of_Attack_Controller">here</a>.</p>
<h2 id="lifting-line"><a class="header" href="#lifting-line">Lifting line</a></h2>
<h3 id="open-source-projects"><a class="header" href="#open-source-projects">Open source projects</a></h3>
<p>Below is a list of other open source lifting line implementations that have similar functionality as Stormbird</p>
<h4 id="cn-aeromodels"><a class="header" href="#cn-aeromodels">CN-AeroModels</a></h4>
<p>An open source implementation of a discrete static lifting line, intended for wind propulsion modeling. The capabilities of this software are very similar to the static lifting line implementation in Stormbird. Can be found <a href="https://gitlab.com/lheea/CN-AeroModels">here</a>.</p>
<h4 id="machupx"><a class="header" href="#machupx">MachUpX</a></h4>
<p>An open source implementation of a discrete static lifting line, intended for wings with and without sweep. Can be found <a href="https://github.com/usuaero/MachUpX">here</a>.</p>
<h3 id="books"><a class="header" href="#books">Books</a></h3>
<p>Some books that might be useful for those interested in learning more about the fundamentals of the lifting line method.</p>
<h4 id="low-speed-aerodynamics-2001"><a class="header" href="#low-speed-aerodynamics-2001">Low-Speed Aerodynamics, 2001</a></h4>
<p>By J. Katz and A. Plotkin. A book that focuses very much on potential theory for air craft applications. Includes a many details about lifting line theory.</p>
<h4 id="fundamentals-of-aerodynamics-2005"><a class="header" href="#fundamentals-of-aerodynamics-2005">Fundamentals of Aerodynamics, 2005</a></h4>
<p>By J.D Anderson. A book about many things within aerodynamics, especially for airplanes, that also have an excellent chapter about the lifting line method and how to implement a basic straight forward version of it.</p>
<h3 id="papers"><a class="header" href="#papers">Papers</a></h3>
<p>Below is a list of papers that either use lifting line methods for sail modeling or serves as direct inspiration for the lifting line method implemented in Stormbird.</p>
<h4 id="vsaero-theory-document-1987"><a class="header" href="#vsaero-theory-document-1987">VSAERO theory document, 1987</a></h4>
<p>By B. Maskew. A detailed description of the theory behind the panel code VSAERO. This includes detailed formulations for how to compute lift-induced velocities for discrete vortex lines. Can be downloaded <a href="https://ntrs.nasa.gov/api/citations/19900004884/downloads/19900004884.pdf">here</a></p>
<h4 id="modern-adaptation-of-prandtls-classic-lifting-line-theory-2000"><a class="header" href="#modern-adaptation-of-prandtls-classic-lifting-line-theory-2000">Modern Adaptation of Prandtl's Classic Lifting-Line Theory, 2000</a></h4>
<p>By W. F. Phillips et al. First known example of a discrete lifting line, as in, capable of modeling multiple wings in the same simulation. Can be downloaded <a href="https://arc.aiaa.org/doi/abs/10.2514/2.2649?journalCode=ja">here</a>.</p>
<h4 id="a-numerical-lifting-line-method-using-horseshoe-vortex-sheets-2011"><a class="header" href="#a-numerical-lifting-line-method-using-horseshoe-vortex-sheets-2011">A Numerical Lifting-Line Method Using Horseshoe Vortex Sheets, 2011</a></h4>
<p>By W. F. Phillips. Another example of a discrete lifting line implementation. Can be downloaded <a href="https://digitalcommons.usu.edu/spacegrant/2011/Session1/4/">here</a>.</p>
<h4 id="numerical-analysis-of-multiple-thin-sail-geometries-based-on-prandtls-lifting-line-theory-2013"><a class="header" href="#numerical-analysis-of-multiple-thin-sail-geometries-based-on-prandtls-lifting-line-theory-2013">Numerical analysis of multiple, thin-sail geometries based on Prandtl’s lifting-line theory, 2013</a></h4>
<p>By R. E. Spall et al. A paper about modeling sails using lifting line theory. The output is compared against other potential theory methods with good results. Can be downloaded <a href="https://www.sciencedirect.com/science/article/pii/S0045793013001606">here</a>.</p>
<h4 id="local-results-verification-of-a-3d-non-linear-lifting-line-method-for-fluid-structure-interactions-simulation-on-a-towing-kite-for-vessels-2017"><a class="header" href="#local-results-verification-of-a-3d-non-linear-lifting-line-method-for-fluid-structure-interactions-simulation-on-a-towing-kite-for-vessels-2017">Local Results Verification of a 3D Non-Linear Lifting Line Method for Fluid-Structure Interactions Simulation on a Towing Kite for Vessels, 2017</a></h4>
<p>By C. Duport et al. Example of a discrete lifting line being used for towing kite modeling. Can be downloaded <a href="https://www.researchgate.net/profile/Kostia-Roncin/publication/330114548_Local_Results_Verification_of_a_3D_Non-Linear_Lifting_Line_Method_for_Fluid-Structure_Interactions_Simulation_on_a_Towing_Kite_for_Vessels/links/5c2e2f41299bf12be3ab2165/Local-Results-Verification-of-a-3D-Non-Linear-Lifting-Line-Method-for-Fluid-Structure-Interactions-Simulation-on-a-Towing-Kite-for-Vessels.pdf">here</a>.</p>
<h4 id="practical-implementation-of-a-general-numerical-lifting-line-method-2021"><a class="header" href="#practical-implementation-of-a-general-numerical-lifting-line-method-2021">Practical Implementation of a General Numerical Lifting-Line Method, 2021</a></h4>
<p>By C. Goates. Another discrete lifting line method, with particular focus on how to deal with swept wings. Can be downloaded <a href="https://www.researchgate.net/publication/348240031_Practical_Implementation_of_a_General_Numerical_Lifting-Line_Method">here</a>.</p>
<h4 id="rapid-aerodynamic-method-for-predicting-the-performance-of-interacting-wing-sails-2023"><a class="header" href="#rapid-aerodynamic-method-for-predicting-the-performance-of-interacting-wing-sails-2023">Rapid aerodynamic method for predicting the performance of interacting wing sails, 2023</a></h4>
<p>By K. Malmek et al. About a lifting line method that employs a practical simplification; rather than solving for the vortex strength on the individual line elements, the lift and drag on a single sail is computed directly from the simplified elliptic wing equations for 3D effects, as a function of the local angle of attack. Interaction effects between multiple sails are still computed using a discrete lifting line approach, but with where the circulation distribution is assumed to be elliptic. This allows for a quicker solution, but still with good results. A similar simulation type is possible in Stormbird, by using a "prescribed circulation" with an elliptical shape. Can be downloaded <a href="https://www.sciencedirect.com/science/article/pii/S0029801823029803?via%3Dihub">here</a>.</p>
<h2 id="actuator-line-1"><a class="header" href="#actuator-line-1">Actuator line</a></h2>
<h3 id="papers-1"><a class="header" href="#papers-1">Papers</a></h3>
<h4 id="numerical-modeling-of-wind-turbine-wakes-2002"><a class="header" href="#numerical-modeling-of-wind-turbine-wakes-2002">Numerical Modeling of Wind Turbine Wakes, 2002</a></h4>
<p>By J. N. Sørensen and W. Z. Shen. As far as we know, the first paper about actuator line modeling. Introduces the method in a general sense. Can be downloaded <a href="https://asmedigitalcollection.asme.org/fluidsengineering/article/124/2/393/444521/Numerical-Modeling-of-Wind-Turbine-Wakes">here</a>.</p>
<h4 id="actuator-disc-methods-applied-to-wind-turbines-2004"><a class="header" href="#actuator-disc-methods-applied-to-wind-turbines-2004">Actuator Disc Methods Applied to Wind Turbines, 2004</a></h4>
<p>By R. F. Mikkelsen. A PhD thesis that include investigations of actuator line modeling. The thesis introduces the concept of using a 'planar force distribution' that is constant along a line section. The same principle is used in Stormbird. Can be downloaded <a href="https://backend.orbit.dtu.dk/ws/portalfiles/portal/5452244/Robert.PDF">here</a>.</p>
<h4 id="a-comparison-of-actuator-disk-and-actuator-line-wind-turbine-models-and-best-practices-for-their-use-2012"><a class="header" href="#a-comparison-of-actuator-disk-and-actuator-line-wind-turbine-models-and-best-practices-for-their-use-2012">A Comparison of Actuator Disk and Actuator Line Wind Turbine Models and Best Practices for Their Use, 2012</a></h4>
<p>By L A. Martinez et al. A paper that tests different settings for actuator line simulations. Can be downloaded <a href="https://www.researchgate.net/publication/271374677_A_Comparison_of_Actuator_Disk_and_Actuator_Line_Wind_Turbine_Models_and_Best_Practices_for_Their_Use">here</a>.</p>
<h4 id="an-advanced-actuator-line-method-for-wind-energy-applications-and-beyond-2017"><a class="header" href="#an-advanced-actuator-line-method-for-wind-energy-applications-and-beyond-2017">An Advanced Actuator Line Method for Wind Energy Applications and Beyond, 2017</a></h4>
<p>By M. Churchfield et al. Introduces two "advanced" functionalities for actuator line simulations (both of which are also available in Stormbird): the concept of an anisotropic force distribution and weighted integral sampling of the control point velocity. Results from this paper suggest that the shape of the force projection can have a large influence on the accuracy, and that an anisotropic force projection is more correct than an isotropic one. Can be downloaded <a href="https://www.nrel.gov/docs/fy17osti/67611.pdf">here</a>.</p>
<h4 id="spanwise-flow-corrections-for-tidal-turbines-2018"><a class="header" href="#spanwise-flow-corrections-for-tidal-turbines-2018">Spanwise Flow Corrections for Tidal Turbines, 2018</a></h4>
<p>By A. Wimshurst and R. Willden. A paper that discusses different spanwise flow corrections in the context of using actuator line models for tidal turbines. Can be downloaded <a href="https://www.researchgate.net/publication/336979652_Spanwise_flow_corrections_for_tidal_turbines">here</a>.</p>
<h4 id="a-new-tip-correction-for-actuator-line-computations-2020"><a class="header" href="#a-new-tip-correction-for-actuator-line-computations-2020">A new tip correction for actuator line computations, 2020</a></h4>
<p>By K. O. Dag and J. N. Sørensen. A paper that introduces a new tip correction method for actuator line simulations based on lifting line theory. They suggest to run to lifting line calculations in parallel with the actuator line simulation; one with a viscous core length equal to the force projection width, and one with a very small core length. The difference in velocity can then be used to correct the raw sampled velocity from the CFD grid. The same method is available in Stormbird. Can be downloaded <a href="https://onlinelibrary.wiley.com/doi/epdf/10.1002/we.2419">here</a>.</p>
<h4 id="a-rans-bem-method-to-efficiently-include-appendage-effects-in-rans-based-hull-shape-evaluation-2021"><a class="header" href="#a-rans-bem-method-to-efficiently-include-appendage-effects-in-rans-based-hull-shape-evaluation-2021">A RANS-BEM Method to Efficiently Include Appendage Effects in RANS-Based Hull Shape Evaluation, 2021</a></h4>
<p>By H. Renzsch et al. A paper about the use of actuator lines to model a sail boat keel.Can be downloaded <a href="https://www.researchgate.net/publication/350027407_A_RANS-BEM_Method_to_Efficiently_Include_Appendage_Effects_in_RANS-Based_Hull_Shape_Evaluation">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<script src="plot_scripts/plot_settings.js"></script>
<h1 id="validation-data"><a class="header" href="#validation-data">Validation data</a></h1>
<p>This chapter contains useful references for extracting data about the lift and drag on different wind propulsion devices, that, for instance, can be used to validate a simulation setup. The most relevant comparison data are from methods that can be considered to be <em>higher fidelity</em> than the methods in Stormbird. In other words, the articles below mostly contain data from either CFD, experiments, or some type of processing of full-scale measurements.</p>
<h2 id="wing-sails"><a class="header" href="#wing-sails">Wing sails</a></h2>
<h3 id="relevant-papers"><a class="header" href="#relevant-papers">Relevant papers</a></h3>
<ul>
<li><strong><a href="https://www.sciencedirect.com/science/article/pii/S0029801814002637?via%3Dihub">Comparison of full 3D-RANS simulations with 2D-RANS/lifting line method calculations for the flow analysis of rigid wings for high performance multihulls</a></strong> (2014), by K. Graf and more. Paper that contains experimental results for a single element wing sail and CFD results for a two-element wingsail.</li>
<li><strong><a href="https://www.sciencedirect.com/science/article/pii/S0029801823029803?via%3Dihub">Rapid aerodynamic method for predicting the performance of interacting wing sails</a></strong> (2023) by K. Malmek and more. Paper about a lifting line method for wind propulsion devices, that also contains CFD data for validation purposes. The CFD results are particularly useful for validating interaction effects.</li>
<li><strong><a href="https://onepetro.org/JST/article/9/01/110/569569/Wind-Tunnel-Tests-of-a-Two-Element-Wingsail-with">Wind Tunnel Tests of a Two-Element Wingsail with Focus on Near-Stall Aerodynamics</a></strong> (2024), by A. Hillenbrand and more. A paper about an experimental study of a two-element wing sail, with particular focus on how the stall angle is dependent on dynamic situations.</li>
</ul>
<h2 id="rotor-sails"><a class="header" href="#rotor-sails">Rotor sails</a></h2>
<p>The flow around rotor sails are defined by very high lift coefficients and therefore strong tip vortices. They often come with end-plates to specifically reduce the tip losses, and thereby increase lift and reduce drag forces. CFD simulations done on rotor sails in the KSP WIND project indicate that the exact features of the <em>tip-geometry</em> can have large impact on the final results. For instance, the foundation geometry can have a large impact on the forces. These types of geometric details will not be part of a simplified line model of a rotor sails directly. As such, it is <strong>generally necessary to tune the models to achieve the right combination of lift and drag</strong>.</p>
<p>Tuning the lift can generally be done by adjusting the values of the lift coefficients in the sectional model, as the 3D lift is generally very close to the 2D lift for a rotor sail. This is because the lift is not dependent on the angle of attack, in the same way as for a wing sail or suction sail.</p>
<p>The recommended practice when modeling rotor sails is to first adjust the model of a single sail by comparing it to some high-fidelity data source, and then use the Stormbird library when, for instance, interaction effects are of interest.</p>
<h3 id="relevant-papers-1"><a class="header" href="#relevant-papers-1">Relevant papers</a></h3>
<ul>
<li><strong><a href="https://ntrs.nasa.gov/citations/19930090695">Application of the Magnus effect to the wind propulsion of ships</a></strong> (1926), by L. Prandtl. One of the first papers about rotor sails. The text mainly consists of a general discussion about the concept and the history of the first ship using rotor sails for propulsion, namely the <em>The Buckau</em>. However, there is also results from one of the first experiments of rotor sails in the appendix of the paper.</li>
<li><strong><a href="https://www.sciencedirect.com/science/article/pii/S0167610518307396">Experiments on a Flettner rotor at critical and supercritical Reynolds numbers</a></strong> (2019), by G. Bordogna and more. Contains results from experiments where lift, drag and power coefficients on rotor sails where measured at different Reynolds numbers and spin ratios. <strong>Note</strong>: the experiments are performed in a wind tunnel where the rotor extends from the floor to the roof, which indicate that the force measurements should be interpreted as two-dimensional. However, it is mentioned in the article that there might be three-dimensional effects due to the boundary layer along the walls. The measured drag is also so large that there seem to be some three-dimensional effects present. The results are therefore probably most useful as a comparison for lift and power, while the drag values are a bit hard to interpret.</li>
<li><strong><a href="https://doi.org/10.1016/j.oceaneng.2020.107603">Design, operation and analysis of wind-assisted cargo ships</a></strong> (2020), by F. Tillig and more. A paper about methods to set up empirical modeling of wind powered ships. One of the empirical methods presented is for the lift, drag and power consumption of rotor sails, tuned based on full-scale measurements.</li>
<li><strong><a href="https://www.intmaritimeengineering.org/index.php/ijme/article/view/1146/356">Retrofitting of Flettner Rotors – Results From Sea Trials of the General Cargo Ship "Fehn Pollux</a></strong> (2020), by M. Vahs. A paper that really is about the how to analyze sea-trail data from a ship equipped with rotor sails. A part of the paper also contain wind tunnel measurements that originates from a bachelor thesis (original source not found), which gives lift and drag as a function of spin ratio.</li>
<li><strong><a href="http://data.hiper-conf.info/Hiper2022_Cortona.pdf">Levelling the Playing Field: A Numerical Platform for the Fair Comparison of Wind Propulsion Systems</a></strong> (2022), by F. C. Gerhardt and more. A paper mostly about the need to have independent analysis of wind propulsion devices. As part of explaining the rotor sail models, CFD results of lift and drag as a function of spin ratio are presented. This presentation also includes a comparison against other available data sources.</li>
<li><strong><a href="https://blueoasis.pt/wp-content/uploads/2023/10/Nutts2023_proceedings_v4.pdf">Calculation of Flettner rotor forces using lifting line and CFD methods</a></strong> (2023), by A. Östman and more. A paper that compares lifting line simulations against CFD simulations for rotor sails. As part of this, there is both two- and three-dimensional data for lift and drag. The two-dimensional data from this paper is used as the default values in the rotating cylinder sectional model in Stormbird.</li>
<li><strong>Aerodynamics of the Flettner rotor at high Reynolds number</strong> (2024), by F. Deybach and more. <strong>Note</strong>: not yet publicly available. Part of the RINA conference on wind propulsion in 2024. Contains experimental results, where a rotor sail is tested in a wind tunnel at different reynolds numbers and spin ratios, as well with different end plate configurations. Concludes that the lift is not very little sensitive to the Reynolds number.</li>
</ul>
<h3 id="other-data-sources"><a class="header" href="#other-data-sources">Other data sources</a></h3>
<p>The KSP WIND project (the project funding the development of Stormbird) has performed CFD simulations of rotor sails as part of the project. These data are not yet published anywhere, except shown in the plots below. The primary goal of these simulations where to investigate the impact of the foundation on the lift and drag. The result indicate that the foundation can have a huge impact on the forces. A model that does not include the tip vortex on the bottom of the sails can, therefore, be overly optimistic.</p>
<figure>
    <img src="literature/../static/rotor_sail_w_and_wo_foundation.png" alt="Rotor sails">
    <figcaption>Figure 1: Streamlines from CFD simulations of rotor sails with and without the foundation present, to illustrate the strength of the vortices, and the impact on the bottom tip vortex when the foundation is inclined in the simulation. Each version of the sail is simulated dependently, and then the streamlines are combined in post-processing</figcaption>
</figure>
<h3 id="plot-of-data"><a class="header" href="#plot-of-data">Plot of data</a></h3>
<h4 id="three-dimensional-data"><a class="header" href="#three-dimensional-data">Three dimensional data</a></h4>
<div id="rotor-sail-3d-forces"></div>
<script src="plot_scripts/plot_rotor_sail_3d_data.js"></script>
<h4 id="two-dimensional-data"><a class="header" href="#two-dimensional-data">Two-dimensional data</a></h4>
<div id="rotor-sail-2d-forces"></div>
<script src="plot_scripts/plot_rotor_sail_2d_data.js"></script>
<h2 id="suction-sails"><a class="header" href="#suction-sails">Suction sails</a></h2>
<h3 id="relevant-papers-2"><a class="header" href="#relevant-papers-2">Relevant papers</a></h3>
<ul>
<li><strong><a href="https://www.jmwe.org/uploads/1/0/6/4/106473271/aa_suction_sails_turbosail_ventifoil_cousteau_report.pdf">Fondation Cousteau and windship propulsion - 1980 - 1985 - System Cousteau - Pechiney</a></strong> (1985), by B. Charrier and more. A paper about the original suction sail concept, known as turbo sails. Part of the presentation is lift and drag data from the sail for different suction rates based on wind tunnel measurements.</li>
<li><strong><a href="https://repository.tudelft.nl/record/uuid:a681c8e6-552e-45a1-8657-893123a8e06b">Wind Propulsion for Merchant Vessels</a></strong> (2017). A master thesis about how to model ships with wind propulsion, that also contains CFD simulations of suction sails, compared against experimental data from the original Turbosail.</li>
<li><strong><a href="https://www.researchgate.net/publication/355675684_A_CFD_Study_on_Wind_Assisted_Propulsion_Technology_for_Commercial_Shipping">A CFD Study on Wind Assisted Propulsion Technology for Commercial Shipping</a></strong> (2021), by W. Hopes and more. A paper about CFD modeling of suction sails, which includes data on lift and drag.</li>
<li><strong><a href="http://data.hiper-conf.info/Hiper2022_Cortona.pdf">Levelling the Playing Field: A Numerical Platform for the Fair Comparison of Wind Propulsion Systems</a></strong> (2022), by F. C. Gerhardt and more. A paper mostly about the need to have independent analysis of wind propulsion devices. As part of explaining the suction sail model, CFD results of lift and drag for different suction rates and angles of attack is presented.</li>
</ul>
<p>Data from the original <a href="https://en.wikipedia.org/wiki/Turbosail">Turbosail</a> from Charrier et al. (1985) seem to still be the primary data source used in open research. The other papers above typically try to reproduce the same values, only with CFD. That is, the references mentioned do not provide new insight into the performance of the suction sail directly, but attempts reproduce the same values using CFD.  <strong>Important note</strong>: newer producers of suctions sails, such as <a href="https://bound4blue.com/">Bound4Blue</a>, <a href="https://econowind.nl/">Econowind</a> and <a href="https://gtwings.com/">GT Wings</a> uses different designs than the Turbosail, and claim better performance. The Turbosail data should therefore be interpreted as a <em>lower-estimate</em> on the performance of a modern suction sail. However, at the moment, we don't know about any <em>openly available source</em> that document this directly.</p>
<h4 id="three-dimensional-data-1"><a class="header" href="#three-dimensional-data-1">Three dimensional data</a></h4>
<div id="suction-sail-3d-forces"></div>
<script src="plot_scripts/plot_suction_sail_3d_data.js"></script>
<h4 id="two-dimensional-data-1"><a class="header" href="#two-dimensional-data-1">Two dimensional data</a></h4>
<div id="suction-sail-2d-forces"></div>
<script src="plot_scripts/plot_suction_sail_2d_data.js"></script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
